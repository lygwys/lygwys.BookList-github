[图标库](https://www.iconfont.cn/ )   
[ng zorro antd图标](https://ng.ant.design/docs/introduce/zh) 
网易云课堂 微信登录  

ctrl+shift+p  调出命令选择框   

netstat -ano  //查看进程

tasklist|findstr "48756"   //查看进程运行程序
node.exe                   

taskkill /pid 48756 /f  //终止进程

vs2017:   
F6编译
F5运行

ctrl+shift+B生成 
    
trl+F5执行    

vscode:   


[JetBrains ReSharper Ultimate 2018.1 正式版 官方安装激活版(附破解说明)](https://www.jb51.net/softs/550361.html)

[ReSharper配置及用法转](http://www.makaidong.com/IT%E5%8D%9A%E5%AE%A2%E5%9B%AD/35741.shtml)   


最新演示版是  [admin.yoyocms.com](https://pro.52abp.com/account/login)  
演示版源码是  [LTMCompanyName.YoyoCmsTemplate](https://gitee.com/aiabpedu/LTMCompanyName.YoyoCmsTemplate)  


目录  
 
章节1  习目标/学习要求/时间安排/学习形式        
课时1
【免费】课程介绍18:50     
课时2
搭建开发环境17:39   
课时3
码云企业版来管理自己的项目05:19   
课时4
课程入学须知以及常见问题答疑与企业版和免费版的声明09:03   

章节2  52ABP企业级开发框架总体演示介绍   
课时5
52ABP企业级开发框架演示26:58   
课时6
ASP.NET CORE 与ABP以及 DDD串讲介绍55:41   
课时7
项目解决方案结构层说明10:05   
课时8
52abp框架前端Angular项目结构说明﻿26:13   
课时9
Angular视频入门课程介绍-如何使用vscode调试前端代码12:28   
课时10
迁移控制台程序﻿及.netcore自宿主体验12:55   
课时11
码云与github企业版如何做到有效率和规范化的功能开发20:29   

章节3 Windows下的环境部署           
课时12
[windows部署]虚拟机安装配置.net core 差异化工具webdeploy36:42   
课时13
【windows部署】IIS下的.NET CORE环境调试Angular生产环境的配置41:14   
  
章节4  52ABP云书单(Saas)项目实操演练    
课时14
【免费】云书单需求分析及项目介绍演示12:54   
课时15
【免费】创建一个属于自己的云书单项目并提交代码到码云25:42   
课时16
【免费】代码管理的几种方式【额外补充内容】07:54   
课时17
通过BOOK实体讲解ABP分页、automapper、模糊搜索等知识点40:50   
课时18
完成书籍的修改创建删除功能以及automapper的两种用法解析24:20   
课时19
将ABP所有的错误和异常信息发送到前端的配置05:50   
课时20
仓储和依赖注入的关系以及简单阐述下他的设计19:20   
课时21
使用Angular与52ABP的前端入门-菜单栏配置14:46   
课时22
使用Angular与52ABP的前端入门-模块组件-路由16:28   
课时23
52ABP前端Angular-完成书籍书单组件以及模块内容配置15:01   
课时24
使用Angular前端入门-书籍前端页面及自动生成前端服务api32:25   
课时25
使用52abp-Angular前端-nztable表格内容封装说明33:35   
课时26
使用52abp-Angular前端-完成books列表页面呈现功能14:09   
课时27
使用52abp-Angular前端-完善book列表分页功能以及删除功能26:31   
课时28
使用52abp-Angular前端-添加编辑书籍页面功能21:37   
课时29
使用52abp-Angular前端-完成书籍表的增删改查功能与下节安排25:55   
课时30
云书单实操-权限的定义和启动21:42   
课时31
angular下路由权限按钮权限的控制和处理17:05   
课时32
带着思路修复bug以及使用代码生成器前的准备工作06:48   
课时33
【免费】如何快速使用52ABP的代码生成器生成前后端页面31:54   
课时34
快速实现BookTag书籍标签表的内容17:44   
课时35
在abp中给书籍添加tag标签功能-124:33   
课时36
给书籍添加tag逻辑实体解决依赖注入报错解决-227:09   
课时37
手写Angular组件img-show强化book封面图片内容14:50   
课时38
Angular主从组件的用法及NgZorro组件Select选择器的使用-118:10   
课时39
Angular主从组件的用法及NgZorro组件Select选择器的使用-219:11   
课时40
Angular主从组件的用法及NgZorro组件Select选择器的使用-338:59   
课时41
通过select选择器和服务器交互以及使用Csharp多返回值Tuple-427:05   
课时42
开发完成云书单后端业务逻辑代码29:58   
课时43
使用NgZorro的Select选择器制作bookNzselect35:22   
课时44
完成云书单项目的功能10:02   
课时45
多租户介绍及ABP中如何将项目修改Saas化的多租户项目20:32   
课时46
多租户授权模式和租户管理员创建流程35:43   
课时47
使用Angular前端组件qrcode生成二维码功能26:52   
课时48
完善二维码访问创建云书单公共分享页面46:02   
课时49
懒加载使用完成云书单项目以及下一阶段事宜说明35:32   

章节5  52ABP快速开发-中高级篇   
课时50
模块化设计及ABP启动加载说明32:23   
课时51
依赖注入的好处和场景说明及abp中如何使用控制反转27:42   




## 章节1 学习目标/学习要求/时间安排/学习形式    
### 课时1 课程介绍18:50   
技术选型 代码管理 团队协同   
Angular和.net core如何结合  
基于DDD 
目标：了解52ABP设计机制，快速开发企业级项目，排查、定位、处理问题  
技术与工具： 
  
	语言：C#、Typescript  
	框架：.Net Core Angular  
	开发工具：Visual Studio 2017  Visual Studio Code    
	数据库：SQL Server 2012+  
	缓存：本地缓存、Redis   
	浏览器：Chrome Firefox   
	FTP客户端：FileZilla  

教学形式与内容  
 
	码云高校版配合管理
	文档和图文教程的配合
	Git工具管理代码
	敏捷开发模式
	协同开发，学生和开源贡献者的双重身份
	52ABP企业版源码随时访问
	定期直播答疑
 
### 课时2 搭建开发环境17:39        
[52ABP框架编程指南](https://gitee.com/aiabpedu/dashboard/wikis/aiabpedu%2F52abp_framework_programming?doc_id=183193&sort_id=832102)     
Settings Sync说明：（未记住第一个id，可访问配置的）
F1-sync-选择上传或下载或重置  
  
*My VSCjode settings:
code-settings-sync:
GitHub Token: cab3ee21720157a435b82fe8d9a68d6ffe6645e4
GIST ID : 00b981d95e4fc5f31bd31b4b2c29c292
GIST ID : 98dc7209dc173e86e432e029e006800e(20181029)

52abp:
GitHub Token: 2ffb827634ddc0f6a59784b022f711424c41c51a
GitHub Gist: b7f414f444f3da950be8e97ecf532495*   

使用公开的设置：  
重置设置-高级选项-从公开的Gist下载设置-下载设置-输入：    
1d56342eea7ba632d3dd6af70c48c84b
-下载设置的选项-重启自动安装     


2019年1月9日    
1  github上生成的第二要旨令牌（仅显示一次，要复制下来）：9afe7d67f01356ff02da7f72576f6676581375ad  
2  vscode上传后生成：   
Sync : 上传完成. GIST ID : 1a78ff2def7ed98264f6fa5f3e8fa01c .请在其他计算机上复制并使用此ID以下载设置.    


您可以随时通过以下网址规则来验证你创建的gist：
https://gist.github.com/{your_userName}/{gist_id}  
https://gist.github.com/lygwys/9afe7d67f01356ff02da7f72576f6676581375ad  
https://gist.github.com/lygwys/1a78ff2def7ed98264f6fa5f3e8fa01c

【前端执行yarn报错，用yarn install可以】     
 [yarn指南及下载](https://yarnpkg.com/zh-Hans/docs/getting-started)

   
### 课时3 码云企业版来管理自己的项目05:19  
fork->PR

### 课时4 课程入学须知及常见问题与企业版和免费版的声明  
admin.yoyocms.com  企业版演示  
free.yoyocms.com  免费版演示
  
## 章节2 52ABP企业级开发框架演示    
### 课时5 52ABP企业级开发框架演示26:58  
fork后  
强制同步-克隆-克隆/下载-复制  
目标文件夹内右击Git Bash here打开git 输入git clone     
shift+inset 粘贴  
执行的完整命令是： 

	$ git clone https://gitee.com/wys5997/LTMCompanyName.YoyoCmsTemplate.git

[Git 知识大全](https://gitee.com/help/categories/43)

此时gitee文件夹中多了新的文件夹 LTMCompanyName.YoyoCmsTemplate/   

将WEB设为启动项，修改连接字串为     

	Data Source=.; Database=YoyoCmsTemplate_db; User ID=52abp; Password=52abp;


F6编译       
PM>update-database  迁移 生成了空库    
Ctrl+F5运行 初始化User数据 生成了两个用户    
登录:default admin 123qwe  

多租户默认不启用设置在：LTMCompanyName.YoyoCmsTemplate.Core/YoyoCmsTemplateCoreModule.cs      

初始化内容在：。/EntityFrameworkCore/Seed/   
SeedHelper.cs做了处理，使项目启动时生成库    


前端：     
yarn install或npm i前端还原包  推荐使用yarn（打开baac）,包存在本地  
npm start 启动  

如何决定端口：   
1appsettings.json    

	"CorsOrigins": "*"  //最好设置一下，逗号分隔完整域名。不要全局通用  

关于更改端口号：  
客户端设置端口设置   
package.json: "dev": "ng serve --host 0.0.0.0 --port 9900 -o    ",
src/assets/appconfig.dev.json:   
  "remoteServiceBaseUrl": "http://localhost:6297",【6297同服务端发布端口】   
  "appBaseUrl": "http://localhost:9900",   
服务端添加相应端口设置   
appsettings.json:"CorsOrigins": "http://localhost:4200,http://localhost:8080,http://localhost:8081,http://localhost:4400,http://localhost:9900"
   
gitee.com使用  
团队资源管理器-更改  可看到所有更改内容，打开可看到对比版本        

### 课时6 ASP.NET CORE 与ABP以及 DDD串讲介绍55:41   

不要复制粘粘代码   
abp分层架构   
https://github.com/52abp  项目介绍（文档、模块、代码生成器。。。）     
DDD简述  表现层 应用层不包含业务逻辑  领域层实体进行打交道 基础设施层    

[github上的项目-文档、工具等](https://github.com/52ABP)  
[Abp 框架中文文档](https://www.52abp.com/ReadWiki/ABP%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/Documents-3.7.2/Readme.md)
前端脚手架: Ant Design,Ng Zorro,Ng-alain,Angular6  
 
### 课时7 项目解决方案结构层说明10:05  
【gitee项目有变更】
    
### 课时8 52abp框架前端Angular项目结构说明﻿26:13  
[Angular文档](https://www.angular.cn/docs)

_mock/  
_nginx/ 不用管
.vscode/ 项目配置文件  
 launch.json 默认debug功能配置，可做到单点调试   
 settings.json 包括电脑设置和工作区设置两种，不要动它，跟着规范走  
dist/ 编译出的生产环境内容   
e2e/ 相关测试，不用管  
node_modules/ 前端加载的包 国内防火墙的问题 
nswag/ 基于后端swagUI来的，其于RX的反射和swagger.json反编译而生成的一套流程（工具）。用法：后端创建了一个方法，只要将IP和域名两两对应，前台调用refesh.bat处理。如果有变化会生成在shared/service-proxies/中，这个文件夹不用动，最多是手动配置一下service-proxy.module.ts   
[以下就是有关前端Ng Alain的内容 ](https://ng-alain.com/docs/architecture/zh)     
[Ant Design of Angular](https://ng.ant.design/docs/introduce/zh)     
[G2 可视化图形语法-Antv 图表](https://antv.alipay.com/zh-cn/g2/3.x/index.html)
[ng-alain专栏-知乎](https://zhuanlan.zhihu.com/ng-alain)   
  
src   

.dockerignore  
.editorconfig
.gitignore  
.prettierignore      
.prettierrc  
.stylelintrc  
angular.json 服务于Angular     
docker-compose.debug.yml   
docker-compose.yml   
Dockerfile   
LICENSE  ng-alain的协议  
package.json  npm包管理
README-zh_CN.md  
README.md  
tsconfig.json  服务于Angular   
tslint.json  服务于Angular    
web.config  IIS中用    
yarn.lock  yarn包管理兼容package.json，所以用npm加载的包可以用yarn进行管理     
yoyocmstemplate.code-workspace      
         
src中的内容是模块化组件化管理  
account/ 帐户控制器模块  
 layout/ 布局组件  
 login/ 登录组件  
 passwords/ 组件  
 register/ 注册组件  
 tenant/ 组件  
 tenant-register/ 组件  
 account-routing.module.ts 路由控制 
 account.component.html 
 account.component.less
 account.component.ts   
 account.module.ts
app/  
assets/ 静态环境存放，包括开发与生产环境的配置   
environments/  
layout/  布局   
shared/  公共的内容，包括编辑器    
styles/  
AppPreBootstrap.ts
browserslist  
delon.module.ts  
favicon.ico  
hmr.ts  
index.html  
karma.conf.js  
main.ts  
polyfills.ts  
root-routing.module.ts  根层是核心    
root.component.ts 根层是核心   
root.module.ts  根层是核心     
style-icons-auto.ts  
style-icons.ts  
styles.less  
test.ts  
tsconfig.app.json  
tsconfig.spec.json  
tslint.json  
typings.d.ts   

### 课时9 Angular视频入门课程介绍-如何使用vscode调试前端代码  12：28     

[调试](https://code.visualstudio.com/docs/editor/debugging#_launch-configurations)

删除.vscode/launch.json,点debug 显示没有配置-添加-chome就可重新自动建起来。第一次会下载安装一些包，并且我的版本没有生成最后一句"sourceMaps": true    

	{
	  // Use IntelliSense to learn about possible attributes.
	  // Hover to view descriptions of existing attributes.
	  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
	  "version": "0.2.0",
	  "configurations": [
	
	    {
	      "type": "chrome",
	      "request": "launch",
	      "name": "Launch Chrome against localhost",
	      "url": "http://localhost:8080",
	      "webRoot": "${workspaceRoot}",
	      "sourceMaps": true
	    }
	  ]
	}


启动中有 --source-map=false就不支持在vscode中进行断点调试了，所以进行断点调试，要在控制台中进行>npm run dev 

    "start": "ng serve --host 0.0.0.0 --port 8080 -o --source-map=false  ",
    "dev": "ng serve --host 0.0.0.0 --port 8080 -o    ",
    "build": "ng build --prod --build-optimizer",   

调试：  
1>npm run dev      
2F5 调出单独的可进行调试的chome浏览器及调试工具条    
3光标放变量上或选中即可看到值    

可在调试面板中添加其它调试的配置   


### 课时10 迁移控制台程序及.netcore自宿主体验  

是给运维人员用的。在开发环境下F5，可执行原来一系列的：将web高为启动项，ef执行迁移，启动初始化数据库等一次性完成。  
普通发布，要在core环境下才能执行迁移控制台。         
在独立发布环境下，多了只需执行exe文件即可，可以修改数据库名称。  

一般情况fork一个项目后，切一个自己的分支dev-itm,master分支为只读   
 
### 课时11 码云与github企业版如何做到有效率和规范化的功能开发   

#### 码云中无冲突处理
码云中可看到"指派给我"处理的提交内容对比“文件改动”，没有冲突的可点左上角“接受”可同步下来，然后       

本地VS中操作：   
合并后从VS中分支- 操作-查看-历史记录  
操作-打开命令提示符->git pull 拉取所有远程分支内容进来，这时历史记录看到已同步到本地了  
选中远程的master分支可看到新的同步记录   
 
选中本地的master分支，执行>git pull，可以看到变化的几条内容与一致  历史记录中显示本地master与远程master同步了  
  
将远程的master分支合并到开发分支上来：分支-将各种分支合并到各种分支上来     

#### gitee冲突处理，“查看怎样操作”有提示三步
   
1VS切换到主分支，代码方式是：git checkout master  
2拉取变更(pull皮蛋的），VS命令提示符中执行：git pull https://titee.com.....master    
冲突选“全部重载”  VS提示有两处冲突  点“合并”可看到冲突详情，选择一种修改，点右上角“接受”    
再点“合并”同样解决第二条冲突   
对于.csproj的冲突类型两种都选择，防止信息丢失   
3推送到远程master分支：git push origin master   

"更改"-“提交临时数据”写感谢皮蛋的话        

#### github中的冲突处理

github中提示的解决办法：     
第一步：  
git fetch origin //获取到源信息   
git checkout -b dev-ngmodel origin /dev-ngmodel //进入开发分支与源分支进行比对   
git merge master //合并到master分支     
第二步：    
git checkout master  //切换到master分支   
git merge --no-ff dev-ngmodel  //合并到本地master分支  
git push origin master //推送到上面master分支 
 


注意：码云的强制拉取功能会覆盖所有改变，所以应在自己的分支上开发  


## 章节3

### 课时12[windows部署]虚拟机安装配置.net core 差异化工具webdeploy 36:42

azure 世纪互联新建SQL虚拟机，二三分钟可完成，只有它是按分钟收费的    
也可不创建虚拟机而创建应用服务，是最快的  

chrome密码插件 LastPass 跨浏览器密码同步管理工具  

远程桌面命令   mstsc   

自带了SQL，管理器中要把SQL Server(MSSQLSERVER)服务设成启动项        

安装IIS   

copy一个chrome浏览器安装包、vscode安装包   

启动网站本地可以访问，ip不行，可在“所有资源”-入站规则目标端口范围中添加80-20000端口  

安装.net core环境：  
百度中搜索.net core  -  点dotnet.github.io -  downloads - 选择hosting / sdk 两个环境都装上   
.net core自主运行，无托管代码 donet ddd.dll   

### 差异化工具webdeploy

AIIS中安装webdeploy   
点IIS右侧Get New Webplatform Components -> Insall this extension  
下载安装后重新打开IIS  多了Webplatform Istaller图标  关掉其它页面 会启动Web Platform Installer 5.1  
在其界面中搜索web deploy   
先安装Web Deploy 3.5 for Hosting Server (一定要先安装 再升级）     
再安装Web Deploy 3.6 for Hosting Server    
IIS中Stop再重启IIS，打开Management Service 默认不用配置   
在IISWebSite目录中新建两个.net Core站点Host 端口801和Admin 端口802   

B修改SQL sa密码 启用并测试远程连接成功   

C发布  
项目右键-发布-选IIS、FTP等-选中配置-发布
（连接 的发布方法中选 Web Deploy包）         
填写远程服务器IP、站点名称Host、用户名和密码（虚拟机)、验证连接并保存密码    
在下一页中勾选“在运行时使用此连接字符串”并修改连接字符串的sa密码     
发布成功，但浏览520错误      

### 课时13[windows部署]IIS下的.NET CORE环境调试Angular生产环境的配置  41：14

IIS放开端口即可  

Angular部署：  

	yarn
	npm run build

将生成的文件拷贝到IIS中  
vscode修改以下文件：
appconfig.json  端口分别为801  802  
萱宁服务簿怀。production添加跨域http://locallhost:802  
web.config配置  
IIS中下载安装URL Rewrite 2.0
使用百度机改用域名是可以的  
本节坑很多  

## 章节4 52ABP云书单需求

### 课时14 云书单需求分析及项目介绍演示 12：54 
 
源代码：https://github.com/52abp/cloud.booklist  
部署地址：https://cloudbook.52abp.com   
项目名称：Cloud.BookList  
自己创建租户的形式，来设计和管理自己的书单内容  

### 章节4课时15【免费】创建一个属于自己的云书单项目并提交代码到码云 25：42  

www.52abp.com注册下载 个人学习用 V3.9.0 项目名称填写lygwys.BookList拷贝代码并解压到gitee   
分别打开

后端：     
设webhost为启动项，修改连接字符串 F6编译    

	PM> update-database   

运行ctrl+F5  

前端：   
检查appconfig-dev.json 端口21021 8080   

	lygwys.BookList\src\booklist-angular>yarn  //还原包

	lygwys.BookList\src\booklist-angular>npm start   //运行  

输入用户名:admin 123qwe


包介绍：    
  
Angular 2, 4 and upcoming latest TypeScript HTML Snippets     
Angular 7 Snippets - TypeScript, Html, Angular Material, ngRx, RxJS & Flex Layout
Angular Language Service   输入有提示
ASP.NET Helper
Auto Close Tag
Auto Import
Auto Rename Tag   
Azure Repos  
Beautify    
Beautify css/sass/scss/less  
Bookmarks
Bootstrap 3 Snippets   
C#
Chinese (Simplified) Language Pack for Visual Studio Code    
Debugger for Chrome   
Docker    
EditorConfig for VS Code     
exports autocomplete      
Git History    
GitLens — Git supercharged     
Guides     
HTML Snippets   
IIS Express    
IntelliSense for CSS class names in HTML     
Latest TypeScript and Javascript Grammar    
Markdown All in One   
markdownlint   
ng-alain snippets   
ng-zorro snippets   
npm  
npm Intellisense    
Prettier - Code formatter    
Quokka.js     
rxjs-snippets    
Sass    
Settings Sync   同步代码属性   
SVG Viewer     
TODO Highlight  高亮     
TSLint    
TypeLens    
vscode-icons   

关闭多租户：lygwys.BookList.Core/BookListCoreModule.cs    

	Configuration.MultiTenancy.IsEnabled = BookListConsts.MultiTenancyEnabled;  //转到定义设为false

	public const bool MultiTenancyEnabled = false; 

F6 F5 单租户了   

开发：  
Core中：    
1.新建文件夹lygwys.BookList.Core/BookListManagement/   
2.新建书类Books/Book.cs      
  新建书单类BooksList/BookList.cs    
3.新建标签类BookTags/BookTag.cs      

	/// <summary>
    /// 书籍
    /// </summary>
    public class Book: CreationAuditedEntity<long>
    {
        /// <summary>
        /// 书名
        /// </summary>
        public string Name { get; set; }
        /// <summary>
        /// 作者
        /// </summary>
        public string Author { get; set; }
	/// <summary>
        /// 简介
        /// </summary>
        public string Intro { get; set; }
        /// <summary>
        /// 价格链接
        /// </summary>
        public string PriceUrl { get; set; }
        /// <summary>
        /// 封面图片Url
        /// </summary>
        public string ImgStrUrl { get; set; }
    }

    /// <summary>
    /// 书单
    /// </summary>
    class BookList : CreationAuditedEntity<long>
    {
        /// <summary>
        /// 书单名称
        /// </summary>
        public string Name { get; set; }
        /// <summary>
        /// 书单简介
        /// </summary>
        public string Intro { get; set; }
    }

    /// <summary>
    /// 书籍标签
    /// </summary>
    class BookTag : CreationAuditedEntity<long>
    {
        /// <summary>
        /// 标签名称
        /// </summary>
        public string TagName { get; set; }
    }


将代码加入码云管理：  
1.点右下角“添加到源代码管理”弹出“部分项目位于解决方案文件夹之外。这些项目将不处于GIT存储库的源代码管理之下。要将所有项目添加到一个GIt存储库中，请将所有项目整合到一个文件夹下。”-确定-确定    出现两种推送方案    
2.在码云中新建仓库（项目）lygwys.BookList,归属组织是自己，公开，勾选所有     
创建-克隆/下载-复制地址： https://gitee.com/wys5997/lygwys.BookList.git   
3.VS中推送到远程-粘贴（未操作发布）    

用的是另一种发布方式，必须的：（因为要包括Angular的内容，把整个大项目纳入管理）    
1.在gitee中新建文件夹     
2.打开“新建文件夹”右击bash,将远程内容克隆过来（也可在地址栏中输入cmd,在当前目录下操作命令行窗口）       

	$ git clone https://gitee.com/wys5997/lygwys.BookList.git

3.将其中的所有文件.git/  .gitee/ README扔到gitee/lygwys.BookList/中    
4.关掉VS，重新打开项目  团队-刷新   
5.gitee/lygwys.BookList/中打开Git Gui    挨顺序点(最后一个不点)：   
Rescan重新扫描     
stase changed留在原地的植物化石 改变，弹出 ：     
Updating the Git index failed.  A rescan will be automatically started to resynchronize git-gui.（更新Git索引失败。重新扫描将自动启动，以重新同步git-gui。）     
点“Unlock Index”按钮  
再点第一次Rescan-stase changed， 这次什么也没弹出     
点sign off打上签名：  Signed-off-by: 王永山 <lygwys@outlook.com>
点Comit提交，提交到本地的库中    
6.***在gitee/lygwys.BookList/文件夹中以vs2017打开，团队传出提交中有了签名文件，点“推送”推送到码云
到此成功发布到码云了。  

### 直播20190110

ci.52abp.com  小陈做的持续集成  
pro.52abp.com 企业版演示  
更新时为什么不更新webcore项目的Swashbuckle.AspNetCore   
vs英文版默认使用consolas字体   
可以使用monaco字体  只要i和M一样宽就行  
解决了审计日志记录密码的bug   
hangfire先看文档   
    
### 章节4课时16【免费】代码管理的几种方式【额外补充内容】  07：54

#### vscode发布到码云

右键项目文件夹BookList以vscode打开    
点版本控制图标，提示未初始化   

	BookList>git init //弹出三个提示信息，都不用管   

源代码管理器下边输入框输入“初始化项目”，点对勾提交到本地   
点左上角...中的“同步”提示“存储库未配置任何要推送到的远程存储库”，这个信息配置在BookList/.git/config中    
  
	Booklist> git remote add origin https://gitee.com/wys5997/lygwys.BookList.git

此时左下角有了推送工具，但提示无法推送，可以强行推送：

	Booklist> git push -f origin master  

刷新码云，看到了项目，然后删除掉  

我在gitee中新建了demo Angular项目，码云中相同项目供测试，没删掉  

#### vscode发布到github  

github中新建项目  

把...or creafe a new repository on the command line
下的代码复制到项目文件夹demo中的run.bat中并运行，生成了.git/ README.md文件 
demo中新建一个任意文件  
demo中右执行Git GuiHere 挨个点，最后push输入git hub账号及密码

刷新github,看到了项目，然后删除掉   

我在gitee中新建了demo-git angular项目,github中相同项目供管理测试，没删掉  


### 章节4课时17通过BOOK实体讲解ABP分页、automapper、模糊搜索等知识点  40：50  

EntityFrameworkCore:   

        #region 书单功能实体
        public DbSet<Book> Books{get;set;}
        public DbSet<CloudBookList> CloudBookLists{ get; set; }
        public DbSet<BookTag> BookTags{ get; set; }
        #endregion


	PM> add-migration Add_CloudBookListEntities
	PM> update-database  

库中出现了三张表   

Application:  

AppConsts.cs中新建两个常量   

        public const int MaxPageSize = 1000;
        public const int DefaultPageSize = 10;

Dtos/PagedInputDto.cs

    public class PagedInputDto : IPagedResultRequest
    {
        [Range(1,AppConsts.MaxPageSize)]
        public int MaxResultCount { get; set; }

        [Range(0,int.MaxValue)]
        public int SkipCount { get; set; }

        public PagedInputDto()
        {
            MaxResultCount = AppConsts.DefaultPageSize;
        }
    }

Dtos/PagedAndFilteredInputDto.cs           

    public class PagedAndFilteredInputDto:PagedAndSortedResultRequestDto
    {
        /// <summary>
        /// 过滤文本
        /// </summary>
        public string FilterText { get; set; }
    }




BookListManagement/Books/Dtos/ BookListDto.cs   

	//[AutoMap(typeof(Book))]
    public class BookListDto:EntityDto<long>
    {
        /// <summary>
        /// 书名
        /// </summary>
        public string Name { get; set; }
        /// <summary>
        /// 作者
        /// </summary>
        public string Author { get; set; }
        /// <summary>
        /// 简介
        /// </summary>
        public string Intro { get; set; }
        /// <summary>
        /// 封面图片Url
        /// </summary>
        public string ImgStrUrl { get; set; }
    }

BookListManagement/Books/Dtos/ GetBookInput.cs    

    public class GetBookInput : PagedAndFilteredInputDto, IShouldNormalize
    {
        public void Normalize()
        {
            if (string.IsNullOrWhiteSpace(Sorting))
            {
                Sorting="Id";
            }
        }
    }


BookListManagement/Books/IBookAppService.cs   

    public interface IBookAppService:IApplicationService
    {
        //分页获取查询书籍的功能
        Task<PagedResultDto<BookListDto>> GetPagedBook(GetBookInput input);
        
        //添加
        
        //删除

        //修改
    }

BookListManagement/Books/Mapper/ BookMpper.cs  

    internal class BookMpper
    {
        public static void CreateMappings(IMapperConfigurationExpression configuration)
        {
            configuration.CreateMap<Book, BookListDto>();   //Book映射成BookListDto
            //configuration.CreateMap< BookListDto, Book>();
        }
    }

BookListApplicationModule.cs注入    

        public override void PreInitialize()
        {
            Configuration.Authorization.Providers.Add<BookListAuthorizationProvider>();

            // 自定义类型映射
            Configuration.Modules.AbpAutoMapper().Configurators.Add(configuration =>
            {
                // XXXMapper.CreateMappers(configuration);
                BookMpper.CreateMappings(configuration);//
            });
        }


BookListManagement/Books/ BookAppService.cs  

    public class BookAppService : BookListAppServiceBase, IBookAppService
    {
        private readonly IRepository<Book, long> _bookRepository;

        public BookAppService(IRepository<Book, long> bookRepository)
        {
            _bookRepository = bookRepository;
        }


        public async Task<PagedResultDto<BookListDto>> GetPagedBook(GetBookInput input)
        {
            var query = _bookRepository.GetAll().AsNoTracking().WhereIf(!input.FilterText.IsNullOrWhiteSpace(),
                a => a.Name.Contains(input.FilterText));
            var count = await query.CountAsync();
            var entityList = await query.OrderBy(input.Sorting).PageBy(input).ToListAsync();
            var entityListDtos = entityList.MapTo<List<BookListDto>>();
            return new PagedResultDto<BookListDto>(count, entityListDtos);
        }
    }     

向数据库中插入一条书籍记录，ctrl+f5 执行，可以正确返回信息           

### 章节4课时18完成书籍的修改创建删除功能以及automapper的两种用法解析  24：20

lygwys.BookList.Application/BookListManagement/Books/Dtos/中 ：     
新建编辑Dto  BookEditDto.cs和添加或修改Dto  CreateOrUpdataBookInput.cs      

    public class BookEditDto
    {
        /// <summary>
        /// 新添加的可空字段，其它都拷贝自Book实体
        /// </summary>
        public long? Id { get; set; }
        /// <summary>
        /// 书名
        /// </summary>
        public string Name { get; set; }
        /// <summary>
        /// 作者
        /// </summary>
        public string Author { get; set; }
        /// <summary>
        /// 简介
        /// </summary>
        public string Intro { get; set; }
        /// <summary>
        /// 价格链接
        /// </summary>
        public string PriceUrl { get; set; }
        /// <summary>
        /// 封面图片Url
        /// </summary>
        public string ImgStrUrl { get; set; }
    }

    public class CreateOrUpdataBookInput
    {
        [Required]
        public BookEditDto Book { get; set; }
    }  


lygwys.BookList.Application/BookListManagement/IBookAppService.cs中新建添加或修改接口、删除、批量删除接口        

        /// <summary>
        /// 添加或修改书籍信息
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        Task CreateOrUpdateBook(CreateOrUpdataBookInput input);


        /// <summary>
        /// 删除书籍
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        Task DeleteBook(EntityDto<long> input);


        /// <summary>
        /// 批量删除数据
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        Task BatchDelete(List<long> input);   



lygwys.BookList.Application/BookListManagement/BookAppService.cs中实现接口   

        public async Task CreateOrUpdateBook(CreateOrUpdataBookInput input)
        {
            if (input.Book.Id.HasValue)
            {
                //修改
                await Update(input.Book);
            }
            else
            {
                //添加
                await CreateBook(input.Book);
            }
        }

        protected virtual async Task<BookEditDto> CreateBook(BookEditDto input)
        {
            //var dd = entity.MapTo(input);//将实体转换为dto
            //ObjectMapper.Map(input, entity);//将实体转换为dto
            //var model=ObjectMapper.Map<Book>(input);//将input转换成Book,尽量用这个，单元测试可以过，单例 数据有效隔离
            var entity = input.MapTo<Book>();//将input转换成Book，静态方法
            await _bookRepository.InsertAsync(entity);
            var dto = entity.MapTo<BookEditDto>();
            return dto;
        }

        protected virtual async Task Update(BookEditDto input)
        {
            Debug.Assert(input.Id != null, "input.Id != null");
            var entity =await _bookRepository.GetAsync(input.Id.Value);
            input.MapTo(entity);
            await _bookRepository.UpdateAsync(entity);
        }


        public async Task DeleteBook(EntityDto<long> input)
        {
            var entity = await _bookRepository.GetAsync(input.Id);
            if (entity !=null)
            {
                await _bookRepository.DeleteAsync(input.Id);
            }
        }

        public async Task BatchDelete(List<long> input)
        {
            await _bookRepository.DeleteAsync(a => input.Contains(a.Id));
        }


lygwys.BookList.Application/BookListManagement/Mapper/BookMpper.cs增加dto映射  

            configuration.CreateMap<BookEditDto, Book>();
            configuration.CreateMap<Book, BookEditDto>();

测试成功！
  
### 章节4课时19将ABP所有的错误和异常信息发送到前端的配置  5：50   

lygwys.BookList.Web.Core/BookListWebCoreModule.cs：           
 
            // TODO:将所有错误信息显示到客户端
            Configuration.Modules.AbpWebCommon().SendAllExceptionsToClients = true;

### 章节4课时20仓储和依赖注入的关系以及简单阐述下他的设计  19:20

Respository仓储是领域层和数据映射层的中介，使用类似集合的接口来存取领域对象。   
依赖注入统一使用ITransientDependency接口，所有实现它的类者自动注册到依赖项，注入为瞬态对象。
ABP中依赖注入是一种设计模式，仓储的实现是设计模式的体现。
两个均来自于领域驱动设计的思想，其核心是划分清晰的边界。

### 章节4课时21使用Angular与52ABP的前端入门-菜单栏配置  14:46

[图标库](https://www.iconfont.cn/ )   
[ng zorro antd图标](https://ng.ant.design/docs/introduce/zh)点中图标，copy,可以粘贴使用了  

给后端打上当前版本标记：V0.1 说明：完成了实体的后端CRUD功能    

多语言设置是在后端实现的，语言库为lygwys.BookList.Core/Localization/SourceFiles/BookList-zh-Hans.xml   

菜单设置在文件中AppMenus.ts   组件的定义在  menu-item.d.ts   

创建菜单：   

	// 书单
    new MenuItem('ClouldBooklist', '', 'anticon anticon-info-circle-o', '', [
      new MenuItem(
        'Booklists',
        '',
        'anticon anticon-book',
        '/app/cloud-book-list/books',
      ),
    ]),


显示登录后主页技术栈栏目下的内容 home.component.ts ：    

	  notice: any[] = [
	    {
	      id: 'members-4',
	      title: '博客园-博文地址',
	      logo: '',
	      link: 'https://www.cnblogs.com/wer-ltm/',
	    },
	
	    {
	      id: 'members-5',
	      title: '博文地址:知乎专栏',
	      logo:
	        'http://wx.qlogo.cn/mmhead/Q3auHgzwzM6PQV7JWIpJ2seavD5UuzCVWPyZs0SVqFkdYRyc3HQUkg/0',
	      link: 'https://zhuanlan.zhihu.com/52abp',
	    },
	    {
	      id: 'members-3',
	      title: '视频课程：腾讯课堂',
	      logo:
	        'http://is4.mzstatic.com/image/thumb/Purple111/v4/06/e9/d3/06e9d3e2-4e07-f556-a765-7c8749f09c12/source/1200x630bb.jpg',
	      link: 'https://ke.qq.com/course/287301?tuin=2522cdf3',
	    },
	  ];
	  loading = false;


### 章节4课时22使用Angular与52ABP的前端入门-模块组件-路由  16：28

### 完善多语言

后端lygwys.BookList.Core/Localization/SourceFiles/BookList-zh-Hans.xml中添加如下，然后后端ctrl+f5,前端刷新就菜单变成中文了            

    <!--云书单模块-->
    <text name="ClouldBooklist" value="云书单" />
    <text name="Booklists" value="书单列表" />

    <!--Common-->
    <text name="HomePage" value="主页" /> 

查看哪些地用到了菜单组件，在AppMenus.ts的class AppMenus右“查看引用” （shift+f12）      

*** 创建自己的组件

停掉前端ctrl+c   
readme中有资料链接   

	booklist-angular>ng g module cloud-book-list

分支提交到本地：生成了模块   

	booklist-angular>ng g c cloud-book-list/book-lists -m cloud-book-list
  
分支中出现了3个文件更改提示M修改的1个，U刚产生的未跟踪状态2个   

*** 全局的路由模块添加  

      // 云书单模块懒加载
      {
        path: 'cloud-book-list',
        loadChildren:
          'app/cloud-book-list/cloud-book-list.module#CloudBookListModule',
        data: { preload: true },//预先加载
      },  

    
### 章节4课时2352ABP前端Angular-完成书籍书单组件以及模块内容配置  15：01

新建书籍列表组件：
	
	booklist-angular>ng g c cloud-book-list/books -m cloud-book-list

菜单修改为：  

    new MenuItem('ClouldBooklist', '', 'anticon anticon-switcher', '', [
      new MenuItem(
        'Booklists',
        '',
        'anticon anticon-book',
        '/app/cloud-book-list/booklists',
      ),
      new MenuItem(
        'Books',
        '',
        'anticon anticon-book',
        '/app/cloud-book-list/books',
      ),
    ]),

书单组件的路由：   
	
	const routes: Routes = [
	  {
	    path: '',
	    children: [
	      {
	        path: 'booklists',
	        component: BookListsComponent,
	      },
	      {
	        path: 'books',
	        component: BooksComponent,
	      },
	    ],
	  },
	];

后台多语言：  

    <!--云书单模块-->
    <text name="ClouldBooklist" value="云书单" />
    <text name="Booklists" value="书单列表" />
    <text name="Books" value="书籍列表" />

编译运行前后台，重新登录，菜单链接展示相应内容   

标签：v0.2 前端完成云书单两个组件添加及管理菜单、全局及组件路由，后端云书单多语言完成

### 章节4课时24使用Angular前端入门-书籍前端页面及自动生成前端服务app  32:25 

模块引入相关Model     cloud-book-list.module.ts：       
	
	@NgModule({
	  imports: [
	    CommonModule,
	    HttpClientModule, //
	    SharedModule, //
	    AbpModule, //
	    CloudBookListRoutingModule,
	  ],
	  declarations: [BookListsComponent, BooksComponent], // 属于该模块的组件、指令和管道（可声明对象）
	  entryComponents: [BookListsComponent, BooksComponent], // 实际使用到的组件，生产环境编译时用到
	  providers: [LocalizationService, TitleService], // 多语言，标题服务,依赖注入实现的一个增强
	})


books.component.ts：   
books组件引入样式、动画       

	@Component({
	  selector: 'app-books',
	  templateUrl: './books.component.html',
	  styles: ['./books.component.less'], // 手动创建样式文件，在当前文件夹中新建books.component.less样式文件
	  animations: [appModuleAnimation], // 动画
	})

修改class(没有引入dto，可以右击nswag-在资源管理器中打开-双击执行自动刷新refrash.bat文件，自动化省去了手写，后台声明的接口都可用.点分支可看到service-proxies.ts多了新接口  如果没有自动出现dto可打开这个文件以刷新内存)     
[NSwag生成客户端调用代码](https://www.cnblogs.com/Leo_wl/p/9328050.html)      
13：03
方法
17：35

	export class BooksComponent extends PagedListingComponentBase<BookListDto>
	  implements OnInit {
	  constructor(injector: Injector, private _bookservice: BookServiceProxy) {
	    super(injector);
	  }
	  /**
	   * 默认获取后端分页数据列表信息
	   * @param request 请求数据的Dto，比如分页的有关
	   * @param pageNumber 当前的页码
	   * @param finishedCallback 完成请求后的回调信息
	   */
	  protected fetchDataList(
	    request: PagedRequestDto,
	    pageNumber: number,
	    finishedCallback: Function,
	  ): void {
	    this._bookservice
	      .getPagedBook(
	        this.filterText,
	        request.sorting,
	        request.maxResultCount,
	        request.skipCount,
	      ) // 传入模糊查询的值
	      .pipe(
	        finalize(() => {
	          finishedCallback();
	        }),
	      ) // angular定义的管道，请求过程中的处理，比如弹出框等
	      .subscribe(result => {
	        // 订阅结束的操作，是有生命周期的
	        this.dataList = result.items;
	        this.showPaging(result);
	      });
	  }
	
	  ngOnInit() {}
	}




公共中写代理注入18：15   service-proxies/service-proxy.module.ts：   

	ApiServiceProxies.BookServiceProxy,

f5调试运行，可看到 Network-XHR 中有所有请求的逻辑    
[XHR简介](https://www.cnblogs.com/syfwhu/p/6116323.htmls)

19：08写html页面  页头 多语言形式   

	<page-header [title]='l(Books)' [desc]='l("书籍列表内容")'></page-header> 

22：26搜索   

	<page-header [title]='l(Books)' [desc]='l("书籍列表内容")'></page-header>
	
	<nz-card [nzBordered]='false'> // 无边框
	  <div nz-row nzGutter="8">
	    <div nz-col nzSpan="24"> // 一行
	      <nz-form-item>
	        <nz-form-control>
	          <nz-input-group nzSearch [nzSuffix]="suffixSearchButton"> // [nzSuffix]="suffixSearchButton"封装好的内置样式-一个图标
	            <input type="text" nz-input [(ngModel)]="filterText" id="filterText" name="filterText" (keyup.enter)="refresh()"
	              placeholder="模糊搜索"> // (keyup.enter)="refresh()"默认回车即刷新页面结果集
	            <ng-template #suffixSearchButton> // 绑定了上边的，相当于做了扩展
	              <button (click)="refresh()" nz-button nzType="primary" nzSearch type="submit">
	                <i class="anticon anticon-search"></i> // 样式增强
	              </button>
	            </ng-template>
	          </nz-input-group>
	        </nz-form-control>
	      </nz-form-item>
	    </div>
	  </div>
	</nz-card>

一个漂亮的搜索框出来了    

[NG-ZORRO](https://ng.ant.design/docs/introduce/zh)连续输如:ng-input-gr 再回车 就会应用代码段  

### 章节4课时25使用52abp-Angular前端-nztable表格内容封装说明 33：25

201901231050代码已提交gitee   

books.component.htm：    

	<!--模糊搜索框-->   
	<!--通用操作按钮-->   
	<!--复选框提供的 已选择*项 清空 刷新-->    
	<!--实体表格内容呈现-->
		<!--暂无数据组件-->
		<!--分页信息增强的内容-->

### 章节4课时26 使用52abp-Angular前端-完成books列表页面呈现功能 14:09    

books.component.ts调整参数顺序为       

    this._bookservice
      .getPagedBook(
        this.filterText, // 绑定的字段
        request.sorting,
        request.skipCount,
        request.maxResultCount,
      ) // 传入模糊查询的值

删除ngOnInit() {}
修改imgUrl为

	<td><img [src]="item.imgStrUrl" /></td>

![26讲完成后页面效果截图](https://i.imgur.com/SsLNkCj.png)

### 章节4课时27 使用52abp-Angular前端-完善book列表分页功能以及删除功能 26:31  

    <!--数据表格-->
    <text name="clearEmpty" value="清空" />
    <text name="NoData" value="暂无数据" />
    <text name="Create" value="新建" />
    <text name="BatchDelete" value="批量删除" />
    <text name="GridFooterDisplayText" value="当前{0}页/共{1}页，共{2}条/显示{3}-{4}条" />
    <text name="GridSelectedXItemsTips">
      <![CDATA[已选择<strong class="text-primary">{0}</strong>项]]>
    </text>

刷新与清空的方法重写也管用了   

12：50删除  

前台   

            <!-- 删除 -->
            <ng-container>
              <nz-popconfirm nzTitle="确定删除码？" (nzOnConfirm)="delete(item)" nzOkText="确定" nzCancelText="关闭">
                <a nz-popconfirm><i class="anticon anticon-delete mr-sm"></i>
                  <span>删除</span></a>
              </nz-popconfirm>
            </ng-container>

代码  

	  delete(entity: BookListDto): void {
	    this._bookservice.deleteBook(entity.id).subscribe(() => {
	      this.refreshGoFirstPage();
	      this.notify.success('信息删除成功');
	    });
	  }
	
	  batchDelete(): void {
	    let selectIdCount = this.selectedDataItems.length;
	    if (selectIdCount <= 0) {
	      abp.message.warn('请选择您要删除的数据信息');
	      return;
	    }
	    abp.message.confirm('是否确认删除以下数据信息？', res => {
	      if (res) {
	        const ids = _.map(this.selectedDataItems, 'id');
	        this._bookservice.batchDelete(ids).subscribe(() => {
	          this.refreshGoFirstPage();
	          abp.notify.success('信息删除成功！');
	        });
	      }
	    });
	  }

 
【页码总数与选择框有问题】
### 章节4课时28 使用52abp-Angular前端-添加编辑书籍页面功能 21:37  

重新运行出现错误  

	ERROR in src/app/cloud-book-list/books/books.component.ts(13,1): error TS1202: Import assignment cannot be used when targeting ECMAScript modules.
	Consider using 'import * as ns from "mod"', 'import {a} from "mod"', 'import d from "mod"', or another module format instead.

引用按提示修改为：  

	// import _ = require('lodash');
	import * as _ from 'lodash';

https://lodash.com    

	booklist-angular>ng g c cloud-book-list/create-or-edit-book m cloud-book-list

提交：完成列表页面以及删除和批量删除功能，增加create-edit页面  

移动文件夹到books,并修改cloud-book-list.module.ts 的新模块引用  

books.component.ts:  (两处用到createOrEdit（）一处带参编辑，一处不带添加)   

	  // 添加&修改页面
	  createOrEdit(id?: number): void {
	    this.modalHelper // 模态框
	      .static(CreateOrEditBookComponent, { id: id }) // 静态模态框，点击提示是否允许关闭，调用组件信息并传id参
	      .subscribe(result => {
	        // 执行后的结果返回前端
	        if (result) {
	          // 是否有值
	          this.refresh(); // 刷新当前列表页面，不管添加还是删除
	        }
	      });
	  }

删除更新import为  

	import { CreateOrEditBookComponent } from './create-or-edit-book/create-or-edit-book.component';  

7:30    
create-or-edit-book.component.ts:   







#### 10:35 后端         

1Books/Dtos中添加DTO：    

    public class GetBookForEditOutput
    {
        public BookEditDto Book { get; set; }
    }  

  
2IBookAppService.cs 增加方法：     

        /// <summary>
        /// 获取编辑状态下的Book实体
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>

        Task<GetBookForEditOutput> GetForEditBookAsync(NullableIdDto<long> input);

3BookAppService.cs中实现接口：   


        public async Task<GetBookForEditOutput> GetForEditBookAsync(NullableIdDto<long> input)
        {
            var output = new GetBookForEditOutput();
            BookEditDto dto;
            if (input.Id.HasValue)
            {
                var entity = await _bookRepository.GetAsync(input.Id.Value);
                dto = entity.MapTo<BookEditDto>();
            }
            else
            {
                dto=new BookEditDto();
            }

            output.Book = dto;

            return output;
        }

ctrl+f5输入id可以返回结果        

#### 15：54 前端       

首先要在资源管理器中执行refresh.bat   
create-or-edit-book.component.ts:     

	export class CreateOrEditBookComponent extends ModalComponentBase
	  implements OnInit {
	  id: any;
	  entity: BookEditDto = new BookEditDto();
	  constructor(injector: Injector, private _bookService: BookServiceProxy) {
	    super(injector);
	  }
	
	  ngOnInit() {
	    this.init();
	  }
	  init(): void {
	    // 编辑
	    this._bookService.getForEditBookAsync(this.id).subscribe(res => {
	      this.entity = res.book;
	    });
	  }
	
	  // 保存方法
	  submitForm(): void {
	    const input = new CreateOrUpdataBookInput();
	    input.book = this.entity;
	    this.saving = true;
	    this._bookService.createOrUpdateBook(input).pipe(
	      finalize(() => {
	        this.saving = false;
	      }),
	    )
	      .subscribe(() => {
	        abp.notify.success('信息保存成功！！');
	        this.success(true);
	      });
	  }
	}

 
### 章节4课时29 使用52abp-Angular前端-完成书籍表的增删改查功能与下节安排 25:55  

	<form nz-form #validateForm="ngForm" (ngSubmit)="submitForm()" nzLayout="horizontal" autocomplete="off">
	  <!-- 模态框头部 -->
	  <div class="modal-header">
	    <div class="modal-title">
	      <i class="anticon anticon-medicine-box mr-sm"></i>
	      <span *ngIf="entity.id">编辑</span>
	      <span *ngIf="!entity.id">添加</span>
	    </div>
	  </div>
	
	  <!-- 模态框详情 -->
	  <fieldset>
	    <nz-form-item nz-row>
	      <nz-form-label nzFor="imgStrUrl" nzXs="24" nzSm="6">封面图片Url</nz-form-label>
	      <nz-form-control nzSm="6" nzXs="24" nz-col nzHasFeedback>
	        <input nz-input #imgStrUrl="ngModel" [(ngModel)]="entity.imgStrUrl" id="imgStrUrl" name="imgStrUrl" placeholder="封面图片Url">
	      </nz-form-control>
	    </nz-form-item>
	
	    <nz-form-item nz-row>
	      <nz-form-label nzFor="name" nzXs="24" nzRequired nzSm="6">书名</nz-form-label>
	      <nz-form-control nzSm="6" nzXs="24" nz-col nzHasFeedback>
	        <input nz-input #name="ngModel" required [(ngModel)]="entity.name" id="name" name="name" placeholder="请输入书名">
	        <!-- 校验内容 -->
	        <nz-form-explain *ngIf="(name.control.dirty || name.control.touched) && name.control.errors">
	          <ng-container *ngIf="name.control.hasError('required')">文本框不能为空</ng-container>
	        </nz-form-explain>
	      </nz-form-control>
	    </nz-form-item>
	
	    <nz-form-item nz-row>
	      <nz-form-label nzFor="author" nzXs="24" nzRequired nzSm="6">作者</nz-form-label>
	      <nz-form-control nzSm="6" nzXs="24" nz-col nzHasFeedback>
	        <input nz-input #author="ngModel" [(ngModel)]="entity.author" id="author" name="author" placeholder="请输入作者信息"
	          required>
	        <!-- 校验内容 -->
	        <nz-form-explain *ngIf="(author.control.dirty || author.control.touched) && author.control.errors">
	          <ng-container *ngIf="author.control.hasError('required')">文本框不能为空</ng-container>
	        </nz-form-explain>
	      </nz-form-control>
	    </nz-form-item>
	
	    <nz-form-item nz-row>
	      <nz-form-label nzFor="intro" nzXs="24" nzSm="6">简介</nz-form-label>
	      <nz-form-control nzSm="6" nzXs="24" nz-col nzHasFeedback>
	        <input nz-input #intro="ngModel" [(ngModel)]="entity.intro" id="intro" name="intro" placeholder="请输入简介">
	      </nz-form-control>
	    </nz-form-item>
	
	    <nz-form-item nz-row>
	      <nz-form-label nzFor="priceUrl" nzXs="24" nzSm="6">购买链接</nz-form-label>
	      <nz-form-control nzSm="6" nzXs="24" nz-col nzHasFeedback>
	        <input nz-input #priceUrl="ngModel" [(ngModel)]="entity.priceUrl" id="priceUrl" name="priceUrl" placeholder="请输入购买链接">
	      </nz-form-control>
	    </nz-form-item>
	  </fieldset>
	
	  <!-- 模态框底部内容 -->
	  <div class="modal-footer">
	    <button (click)="close()" type="button" nzType="default" [disabled]="saving" nz-button><i class="anticon anticon-close-circle-o">取消</i></button>
	    <button type="submit" nzType="primary" nz-button [disabled]="!validateForm.form.valid||saving"><i class="anticon anticon-save">保存</i></button>
	
	
	  </div>
	</form>


 
### 章节4课时30 云书单实操-权限的定义和启动 21:42   

[4.4 ABP应用层 - 权限认证](https://www.52abp.com/wiki/abp-cn/latest/4.4ABP%E5%BA%94%E7%94%A8%E5%B1%82-%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81)

Authorization/PermissionNames.cs中添加两个根节点：   

    public static class PermissionNames
    {
        public const string Pages = "Pages";//
        public const string Pages_Administrator = "Pages.Administrator";//
        public const string Pages_Tenants = "Pages.Tenants";
        public const string Pages_Users = "Pages.Users";
        public const string Pages_Roles = "Pages.Roles";
    }

core中新建文件夹/BookListManagement/Books/Authorization/   
其中新建两个类：    
BookPermissions.cs:    

    /// <summary>
    /// 对书籍权限的声明
    /// </summary>
    public static class BookPermissions
    {
        public const string BookManager = "Pages.BookManager";
        public const string Query = "Pages.Book.Query";
        public const string Create = "Pages.Book.Create";
        public const string Edit = "Pages.Book.Edit";
        public const string Delete = "Pages.Book.Delete";
        public const string BatchDelete = "Pages.Book.BatchDelete";
    }

BookAuthorizationProvider.cs:  

    public class BookAuthorizationProvider : AuthorizationProvider
    {
        public override void SetPermissions(IPermissionDefinitionContext context)
        {
            var pages = context.GetPermissionOrNull(PermissionNames.Pages) ?? context.CreatePermission(PermissionNames.Pages, new FixedLocalizableString("页面"));
            var admin = pages.Children.FirstOrDefault(a => a.Name == PermissionNames.Pages_Administrator)??pages.CreateChildPermission(PermissionNames.Pages_Administrator,L("Administrator"));
            var entityPermission = admin.CreateChildPermission(BookPermissions.BookManager, L("BookManager"));
            entityPermission.CreateChildPermission(BookPermissions.Query, L("Query"));
            entityPermission.CreateChildPermission(BookPermissions.BatchDelete, L("BatchDelete"));
            entityPermission.CreateChildPermission(BookPermissions.Create, L("Create"));
            entityPermission.CreateChildPermission(BookPermissions.Delete, L("Delete"));
            entityPermission.CreateChildPermission(BookPermissions.Edit, L("Edit"));
        }

        private static ILocalizableString L(string name)
        {
            return new LocalizableString(name,BookListConsts.LocalizationSourceName);
        }
    }

注入BookListCoreModule.cs的PreInitialize()中：         

     //给book定义授权信息内容
     Configuration.Authorization.Providers.Add<BookAuthorizationProvider>();

运行-登录-Role-/api/services/app/Role/GetAllPermissions可看到所有权限信息  形如：  

	 {
	        "name": "Pages.Book.BatchDelete",
	        "displayName": "批量删除",
	        "description": null,
	        "id": 0
	      },

由于是模块化，也可注入到Application的 BookListApplicationModule  PreInitialize()中：    

	//给book定义授权信息内容
	            Configuration.Authorization.Providers.Add<BookAuthorizationProvider>();


应用：   
打开书籍表BookAppService.cs   

    [AbpAuthorize(BookPermissions.BookManager)]
    public class BookAppService : BookListAppServiceBase, IBookAppService
    {


        [AbpAuthorize(BookPermissions.Query)]

        public async Task<PagedResultDto<BookListDto>> GetPagedBook(GetBookInput input)

        [AbpAuthorize(BookPermissions.Create,BookPermissions.Edit)]
        public async Task CreateOrUpdateBook(CreateOrUpdataBookInput input)
        {

        [AbpAuthorize(BookPermissions.Edit)]
        protected virtual async Task Update(BookEditDto input)
        {

        [AbpAuthorize(BookPermissions.Create)]
        protected virtual async Task<BookEditDto> CreateBook(BookEditDto input)
        {

        [AbpAuthorize(BookPermissions.Edit)]
        public async Task<GetBookForEditOutput> GetForEditBookAsync(NullableIdDto<long> input)
        {

        [AbpAuthorize(BookPermissions.BatchDelete)]
        public async Task BatchDelete(List<long> input)
        {

        [AbpAuthorize(BookPermissions.Delete)]
        public async Task DeleteBook(EntityDto<long> input)
        {

这次登录后，请求book提示：   

    "message": "您没有权限进行此操作,您至少需要下列权限的其中一项: [Query]",

### 章节4课时31 angular下路由权限按钮权限的控制和处理 17:05   

此时启动前端-编辑角色-已出现了我们添加的权限，但灰色不能选择和编辑，因为角色是static静态角色。    

添加角色bookmanager书籍管理，选择所有权限   

此时点击“书籍列表”、刷新、清空等都显示来自后端的提示：您没有权限进行此操作,您至少需要下列权限的其中一项: [Query]

地址栏输入http://localhost:8080/app/cloud-book-list/books也可看到页面，这是不行的   

用户-将admin赋予 书籍管理 角色    此时，所有操作都是可以的了   

#### 重点是添加路由权限，有权限时显示按钮等信息，没有权限时不显示    

路由权限，路径地址判断    

菜单中添加权限：   

    new MenuItem(
      'ClouldBooklist',
      'Pages.BookManager',//原来是空的
      'anticon anticon-switcher',
      '',
      [  

取消用户的 书籍管理 权限    此时，菜单中不再显示“云书单”菜单了   

把'Pages.BookManager'放到，books菜单中，此时显示云书单及书单列表，不显示书籍菜单  
但地址栏输入http://localhost:8080/app/cloud-book-list/books，仍可访问，不合理  可在书籍模块的路由中添加 , data: {permission: 'Pages.BookManager'}来设定权限解决   

      {
        path: 'books',
        component: BooksComponent, data: {permission: 'Pages.BookManager'}
      },

此时再拼接地址会跳至http://localhost:8080/app/home    



按钮权限
books.component.html：      
所有按钮加权限形如：   

        <button *ngIf="isGranted('Pages.Book.Create')" (click)="createOrEdit()" nzType="primary" nz-button>
          <i class="anticon anticon-plus"></i><span>{{ l('Create') }}</span>
        </button>

新建角色 普通用户组 去掉编辑 删除 添加权限 再新建item用户授予其普通用户组角色，用其登录，就看不到 添加 按钮了  

所有按钮都加上相应的授权：    

        <button *ngIf="isGranted('Pages.Book.BatchDelete')" (click)="batchDelete()" nzType="danger" nz-button>
          <i class="anticon anticon-delete"></i><span>{{ l('BatchDelete') }}</span>
        </button>


              <a (click)="createOrEdit(item.id)" *ngIf="isGranted('Pages.Book.Edit')">
                <i class="anticon anticon-edit mr-sm"></i>
                <span>{{ l('Edit') }}</span>
              </a>

            <ng-container *ngIf="isGranted('Pages.Book.Delete')">
              <nz-popconfirm nzTitle="确定删除码？" (nzOnConfirm)="delete(item)" nzOkText="确定" nzCancelText="关闭">
                <a nz-popconfirm><i class="anticon anticon-delete mr-sm"></i>
                  <span>删除</span></a>
              </nz-popconfirm>
            </ng-container>


此时用item登录将不显示 添加 删除 修改 按钮   

提交：完成书籍表的所有功能，包含权限的解释和说明。  


### 章节4课时32 带着思路修复bug以及使用代码生成器前的准备工作 06:48   

【按说的方法，仍没解决选择计数问题】  
合并到master分支     
切到dev-lygwys分支，删除所有完成的内容仅保留菜单内容：   
后端删除：       
Application/BookListManagement/    
Core/BookListManagement/Books/Authorization/    
前端删除：   
cloud-book-list/books/  

可以正常运行前端           
      
提交：清除所有的book的组件和后端服务   

[gitee老出问题，主要是。net core文件夹打不开所以改到github上,按前面16课时补充的方法，神速上传！https://github.com/lygwys/lygwys.BookList-github.git]

提交：清除所有的book的组件和后端服务   


### 章节4课时33 免费】如何快速使用52ABP的代码生成器生成前后端页面 31:54   

1安装：    
VS2017-工具-扩展更新-
VS Marketplace-搜索52abp-安装ABP Code Power Tools by 52abp.com   

2右击Book.cs生成代码： 32个文件  
包括说明文件：readme.md   
根下52abp-code-power/Bookjson    solutionInfo.json   
一些常量爱用不用  DTO  map  CRUD

考虑降低复杂度，删除EF中的EntityMapper/       

3按生成的说明文件配置：     

# 使用说明:

**配置Automapper** :

复制以下代码到Application层下的：BookListApplicationModule.cs
中的 PreInitialize 方法中:

```
// 自定义类型映射
// 如果没有这一段就把这一段复制上去
Configuration.Modules.AbpAutoMapper().Configurators.Add(configuration =>
{
    // ....

    // 只需要复制这一段
BookMapper.CreateMappings(configuration);

    // ....
});

```

**配置权限功能**  :

如果你生成了**权限功能**。复制以下代码到 BookListApplicationModule.cs
中的 PreInitialize 方法中:(我是在Core中配置的)

```
Configuration.Authorization.Providers.Add<BookAuthorizationProvider>();

```

**EntityFramework功能配置**:

可以在```DbContext```中增加：

 ```
public DbSet<Book>  Books { get; set; }

 ```

在方法```OnModelCreating```中添加

```
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.ApplyConfiguration(new BookCfg());
        }

```


**多语言配置**  

.Core 层下 Localization->SourceFiles 中

```

<text name="Name"  value="书名"></text>
<text name="Author"  value="作者"></text>
<text name="Intro"  value="简介"></text>
<text name="PriceUrl"  value="购买链接"></text>
<text name="ImgStrUrl"  value="图片链接"></text>


<text name="Book" value="书"></text><text name="QueryBook"  value="查询书"></text><text name="CreateBook"  value="添加书"></text><text name="EditBook"  value="编辑书"></text><text name="DeleteBook"  value="删除书"></text><text name="BatchDeleteBook" value="批量删除书"></text><text name="ExportBook"  value="导出书"></text>                             

```

ctrl+shift+B   
ctrl+f5  
提示有重复的键，删除多语言中的“Name”就可   

15:14  前端配置     
将生成的前端代码books/拷贝到前端cloud-book-list/内 
     
按readme.md操作(文件不对仍是后端说明)  

1service-proxy.module配置：     
执行nswag/refresh.bat   地址栏输入cmd回车，再按Tab补全命令  
再到/src/shared/service-proxies/service-proxy.module.ts中添加：    

	ApiServiceProxies.BookServiceProxy,

2菜单配置   
AppMenus.ts中添加   

      new MenuItem(
        'Book',
        'Pages.Book',
        'anticon anticon-dashboard',
        '/app/cloud-book-list/book',
      ),

	//cloud-book-list可自行更改为某模块之下

3路由配置  
src/app/cloud-book-list/cloud-book-list-routing.module.ts中添加  

      {
        path: 'book',
        component: BookComponent,
        data: { permission: 'Pages.Book' },
      },

4在本模块的Module中，添加到使用的@NgModule中的代码，在declarations项中   

	BookComponent,  
	CreateOrEditBookComponent, 

在entryComponents项中   

	CreateOrEditBookComponent,   

5运行   

	booklist-angular>npm start     

添加角色权限，OK！  

图片链接应显示图片book.component.html:   

              <!-- <span nz-tooltip [nzTitle]="item.imgStrUrl">
                                {{item.imgStrUrl}}
                            </span> -->

              <img [src]="item.imgStrUrl" />

提交：完成书籍表的CRUD     

合并到主分支  通过代码生成器完成书籍表的CRUD同步到主分支

打标签0.4  通过代码生成器完成书籍表的CRUD及一些基类信息，推到github  

### 章节4课时34 快速实现BookTag书籍标签表的内容 17:44   

切换到master-同步-操作-打开命令提示符 >git pull 远程拉取所有代码 -查看历史记录  如果显示远程与本地处于同一版本则可下一步   

生成代码BookTag.cs:  

# 使用说明:

**配置Automapper** :

复制以下代码到Application层下的：BookListApplicationModule.cs
中的 PreInitialize 方法中:

```
// 自定义类型映射
// 如果没有这一段就把这一段复制上去
Configuration.Modules.AbpAutoMapper().Configurators.Add(configuration =>
{
    // ....

    // 只需要复制这一段
BookTagMapper.CreateMappings(configuration);

    // ....
});

```

**配置权限功能**  :

如果你生成了**权限功能**。复制以下代码到 BookListApplicationModule.cs
中的 PreInitialize 方法中:

```
Configuration.Authorization.Providers.Add<BookTagAuthorizationProvider>();

```

**EntityFramework功能配置**:

可以在```DbContext```中增加：

 ```
public DbSet<BookTag>  BookTags { get; set; }

 ```

在方法```OnModelCreating```中添加       //这个暂时不用

```
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.ApplyConfiguration(new BookTagCfg());
        }

```


**多语言配置**  

.Core 层下 Localization->SourceFiles 中

```

<text name="TagName"  value="TagName"></text>


<text name="BookTag" value=""></text><text name="QueryBookTag"  value="查询"></text><text name="CreateBookTag"  value="添加"></text><text name="EditBookTag"  value="编辑"></text><text name="DeleteBookTag"  value="删除"></text><text name="BatchDeleteBookTag" value="批量删除"></text><text name="ExportBookTag"  value="导出"></text>                             

```

将生成的前端book-tags/拷入前端cloud-book-list/下 

后端生成并运行   
前端 cmd运行refresh.bat   


# 前端配置
# service-proxy.module 配置

1. 首先在前端项目的根目录中的打开 `nswag-> refresh.bat` 批处理文件更新 service-proxies.ts 文件内容

2. 再到文件夹路径为`\src\shared\service-proxies\service-proxy.module.ts` 文件中添加以下代码：

```
@NgModule({
	providers: [
			//以下内容复制进去
			ApiServiceProxies.BookTagServiceProxy,
			//
			],
	})

```

# 菜单配置， 添加到菜单位置
到`AppMenus.ts`文件中添加菜单路径


> 复制以下最新代码段内容：

```

{text:'BookTag',i18n:'BookTag',acl:'Pages.BookTag',icon:'anticon anticon-dashboard',link:'/app/admin/book-tag'},

```


> 如果您使用的是低版本模板`yoyo-ng-module`的话，请复制以下代码段内容：

```

new MenuItem('BookTag', 'Pages.BookTag', 'anticon anticon-dashboard', '/app/admin/book-tag')

```

> '/app/admin/book-tag') 中的 admin 可以自行更改到你的特定模块下,

# 路由配置， 添加到使用位置路由的代码段


添加以下代码到自己的模块路由中:如`src\app\admin\admin-routing.module.ts`


#### 不带权限
```
{  path: 'book-tag', component:BookTagComponent },
```

#### 带权限验证

```
{  path: 'book-tag', component:BookTagComponent,data: { permission: 'Pages.BookTag' }  },

```

以上二选一
 
 



# 在本组件的 Module 中，添加以下代码到使用的 @NgModule 中的代码
### ================ 在 declarations 项中:

```
BookTagComponent,
CreateOrEditBookTagComponent,

```

### ================ 在 entryComponents 项中:

```
CreateOrEditBookTagComponent,
```    

登录授权，OK！  

按上节操作，先提交dev，再到github上PULL Requer



### 章节4课时35 在abp中给书籍添加tag标签功能-1 24:33  

Core中新建关联表类：   
	
	namespace lygwys.BookList.BookListManagement.Relationships
	{
	    public class BookAndBookTag:Entity<long>
	    {
	        public long BookId { get; set; }
	        public virtual Book Book { get; set; }
	        public long BookTagId { get; set; }
	        public  virtual BookTag BookTag { get; set; }
	    }
	}


Book.cs  BookTag.cs 都添加一对多关系   

	public virtual ICollection<BookAndBookTag> BookAndBookTags { get; set; }

在书的领域层写方法，也可以在书签的领域层写，但考虑到以书为主写在IBookManager.cs中，坚持约定领域层不出现viewmodel\dto原则上只操作model entity：  

	namespace lygwys.BookList.BookListManagement.Books.DomainService
	{
	    public interface IBookManager : IDomainService
	    {
	
	        /// <summary>
	        /// 初始化方法
	        ///</summary>
	        void InitBook();
	
	        // 处理书籍 标签表中间表的逻辑
	
	        // 通过书籍查询标签
	        Task<List<BookAndBookTag>> GetTagsByBookId(long bookId);
	
	        // 通过标签查询书籍
	        Task<List<BookAndBookTag>> GetBooksByTagId(long tagId);
	        // 创建书籍和标签的关联关系，以书为核心
	
	        Task CreateBookAndBookTagRelationship(long bookId,List<long> tagIds);
	
	    }
	}   

实现之   【

	namespace lygwys.BookList.BookListManagement.Books.DomainService
	{
	    /// <summary>
	    /// Book领域层的业务管理
	    ///</summary>
	    public class BookManager :BookListDomainServiceBase, IBookManager
	    {
			
			private readonly IRepository<Book,long> _repository;
	        private readonly IRepository<BookAndBookTag, long> _bookAndBookTagRepository;  //
	
			/// <summary>
			/// Book的构造方法
			///</summary>
			public BookManager(
				IRepository<Book, long> repository, IRepository<BookAndBookTag, long> bookAndBookTagRepository)
			{
			    _repository =  repository;
			    _bookAndBookTagRepository = bookAndBookTagRepository;
			}
	
	
			/// <summary>
			/// 初始化
			///</summary>
			public void InitBook()
			{
				throw new NotImplementedException();
			}
	        /// <summary>
	        /// 通过书籍查询标签
	        /// </summary>
	        /// <param name="bookId"></param>
	        /// <returns></returns>
	        public async Task<List<BookAndBookTag>> GetTagsByBookIdAsync(long bookId)
	        {
	            var list=await _bookAndBookTagRepository.GetAll().AsNoTracking().Where(a => a.BookId == bookId).ToListAsync();
	            return list;
	        }
	        /// <summary>
	        /// 通过标签查询书籍
	        /// </summary>
	        /// <param name="tagId"></param>
	        /// <returns></returns>
	        public async Task<List<BookAndBookTag>> GetBooksByTagId(long tagId)
	        {
	            var list = await _bookAndBookTagRepository.GetAll().AsNoTracking().Where(a => a.BookTagId == tagId)
	                .ToListAsync();
	            return list;
	        }
	        /// <summary>
	        /// 创建书籍和标签的关联关系
	        /// </summary>
	        /// <param name="bookId"></param>
	        /// <param name="tagIds"></param>
	        /// <returns></returns>
	        public async Task CreateBookAndBookTagRelationship(long bookId, List<long> tagIds)
	        {
	            // 删除原有的关联-书箱上的所有标签
	            await  _bookAndBookTagRepository.DeleteAsync(a=>a.BookId==bookId);
	            await CurrentUnitOfWork.SaveChangesAsync(); //手动处理掉数据-调用工作单元进行操作(相当于DbContent.SaveChangesAsync())
	            //添加关联
	            var newBookTags=new List<long>();
	
	            foreach (var tagId in tagIds)
	            {
	                if (newBookTags.Exists(a=>a==tagId)) // 如果newBookTags中有了tagId，就不执行下面方法，直接再循环处理下一个tagId
	                {
	                    continue;
	                }
	
	                await _bookAndBookTagRepository.InsertAsync(new BookAndBookTag()
	                {
	                    BookId = bookId,
	                    BookTagId = tagId
	                });
	
	                newBookTags.Add(tagId);   
	            }
	
	        }
	
	        // TODO:编写领域业务代码
	        
	
		}
	}
	 
 
### 章节4课时36 给书籍添加tag逻辑实体解决依赖注入报错解决-2 27:09   

lygwys.BookList.Application中：
CreateOrUpdateBookInput.cs添加TagIds:    

	public  List<long> TagIds { get; set; }

BookTagApplicationService.cs修改:    

        public async Task CreateOrUpdate(CreateOrUpdateBookInput input)
        {

            if (input.Book.Id.HasValue)
            {
                await Update(input.Book, input.TagIds); // , input.TagIds
            }
            else
            {
                await Create(input.Book, input.TagIds); // , input.TagIds
            }
        }


        protected virtual async Task<BookEditDto> Create(BookEditDto input, List<long> tagIds) //添加参数, List<long> tagIds


        protected virtual async Task Update(BookEditDto input, List<long> tagIds) // , List<long> tagIds

新增图书修改为：  

        /// <summary>
        /// 新增Book
        /// </summary>
        [AbpAuthorize(BookPermissions.Create)]
        protected virtual async Task<BookEditDto> Create(BookEditDto input, List<long> tagIds) //添加参数, List<long> tagIds
        {
            //TODO:新增前的逻辑判断，是否允许新增

            var entity = input.MapTo<Book>();
            var entityId = await _entityRepository.InsertAndGetIdAsync(entity);

            // 创建关联关系   
            if (tagIds.Count > 0)
            {
                await _entityManager.CreateBookAndBookTagRelationship(entityId, tagIds);
            }

            return entity.MapTo<BookEditDto>();
        }


编辑只增加  // 创建关联关系 

        /// <summary>
        /// 编辑Book
        /// </summary>
        [AbpAuthorize(BookPermissions.Edit)]
        protected virtual async Task Update(BookEditDto input, List<long> tagIds) // , List<long> tagIds
        {
            //TODO:更新前的逻辑判断，是否允许更新

            var entity = await _entityRepository.GetAsync(input.Id.Value);
            input.MapTo(entity);

            // ObjectMapper.Map(input, entity);
            await _entityRepository.UpdateAsync(entity);

            // 创建关联关系   
            if (tagIds.Count > 0)  //
            {
                await _entityManager.CreateBookAndBookTagRelationship(entity.Id, tagIds);
            }
        }

删除要引入关联关系仓储   

    private readonly IRepository<BookAndBookTag, long> _bookAndBookTagRegRepository;


        /// <summary>
        /// 删除Book信息的方法
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        [AbpAuthorize(BookPermissions.Delete)]
        public async Task Delete(EntityDto<long> input)
        {
            //TODO:删除前的逻辑判断，是否允许删除
            await _entityRepository.DeleteAsync(input.Id);
            await _bookAndBookTagRegRepository.DeleteAsync(a => a.BookId == input.Id);  //
        }



        /// <summary>
        /// 批量删除Book的方法
        /// </summary>
        [AbpAuthorize(BookPermissions.BatchDelete)]
        public async Task BatchDelete(List<long> input)
        {
            // TODO:批量删除前的逻辑判断，是否允许删除
            await _entityRepository.DeleteAsync(s => input.Contains(s.Id));
            await _bookAndBookTagRegRepository.DeleteAsync(a => input.Contains(a.BookId)); //
        }


修改GetForEdit：    
新建DTO 标明是否标签被选中BookTagSelectListDto.cs：    

	 namespace lygwys.BookList.BookListManagement.Books.Dtos
	{
	    public class BookTagSelectListDto : BookTagListDto
	    {
	        /// <summary>
	        /// 是否选中
	        /// </summary>
	        public bool IsSelected { get; set; }
	    }
	}

core的IBookTagManager.cs中添加，ABP默认没有提供，所以手动添加一下   Task<List<BookTag>> GetAll(); 

    public interface IBookTagManager : IDomainService
    {
        /// <summary>
        /// 初始化方法
        ///</summary>
        void InitBookTag();
        Task<List<BookTag>> GetAll();  //
    }

并BookTagManager.cs中实现之：   

        public async Task<List<BookTag>> GetAll()
        {
            var models =await _repository.GetAll().AsNoTracking().ToListAsync();
            return models;
        }

注入  

        private readonly IBookTagManager _bookTagManager;  

Application的BookTags中配置映射关系：   

        configuration.CreateMap<BookTag, BookTagSelectListDto>()
                .ForMember(a => a.IsSelected, options => options.Ignore());  //忽略IsSelected

Application/BookListManagement/Books/Dtos/GetBookForEditOutput.cs中添加：  

	   public List<BookTagSelectListDto> BookTags { get; set; } 

完整的方法：   

        /// <summary>
        /// 获取编辑 Book
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        [AbpAuthorize(BookPermissions.Create, BookPermissions.Edit)]
        public async Task<GetBookForEditOutput> GetForEdit(NullableIdDto<long> input)
        {
            var output = new GetBookForEditOutput();
            BookEditDto editDto;
            List<long> bookTagIds = null;  //
            // 获取所有标签信息
            // 哪些是选择了的，哪些不是的  建BookTagSelectListDto

            var bookTagListDtos = (await _bookTagManager.GetAll()).MapTo<List<BookTagSelectListDto>>();  //

            
            if (input.Id.HasValue)
            {
                var entity = await _entityRepository.GetAsync(input.Id.Value);
                editDto = entity.MapTo<BookEditDto>();
                bookTagIds = (await _entityManager.GetTagsByBookIdAsync(entity.Id)).Select(a=>a.BookTagId).ToList();
                if (bookTagIds.Count>0)
                {
                    foreach (var bookTag in bookTagListDtos)
                    {
                        if (bookTagIds.Exists(a=>a==bookTag.Id))
                        {
                            bookTag.IsSelected = true;
                        }
                    }
                }
            }
            else
            {
                editDto = new BookEditDto();
            }

            output.Book = editDto;
            output.BookTags=bookTagListDtos;  //
            return output;
        }


EF中：   

	public  DbSet<BookAndBookTag> BookAndBookTags { get; set; }

	add-migration Add_BookAndBookTagEntity
	PM> update-database    


添加标签：在http://localhost:21021/swagger/index.html
/api/services/app/Book/CreateOrUpdate：

	{
	  "book": {
	    "name": "金庸大红帽9",
	    "author": "金庸",
	    "intro": "全套60本 幼儿童话故事书绘本 宝宝睡前故事书启蒙 睡前有声小故事图书 0-8岁婴幼儿园儿童早教书籍",
	    "priceUrl": "https://item.jd.com/22314639121.html",
	    "imgStrUrl": "https://img11.360buyimg.com/n5/jfs/t20002/156/2470538807/363049/2b750029/5b42ca56N2b63a27b.jpg",
	    "creationTime": "2019-01-25T09:02:24.2178301",
	    "creatorUserId": null,
	    "id": 1
	  },
	  "tagIds": [
	    1
	  ]
	}

### 章节4课时37 手写Angular组件img-show强化book封面图片内容 14:50   

实现：点击小图片弹出大图，使用了子组件模态框   
安装插件Angular Language Service 和 Angular.Files    
将图片移到选择后     
 
在cloud-book-list中新建文件夹components    
提交代码：完善Book添加Tag的逻辑    
右击新建Comnents  输入 img-show   
继承自ModalComponentBase   
     
	export class ImgShowComponent extends ModalComponentBase {
	
	  imgUrl = '';
	  constructor(injector: Injector) {
	    super(injector);
	  }
	}
	
	<img [src]="imgUrl" style="width: 100%;height: 100%;margin-top: 20px">


cloud-book-list.module.ts模块中注入ImgShowComponent（哪用哪注入）   

写单击及方法     

	<img [src]="item.imgStrUrl" alt="封面图片" (click)="showImg(item.imgStrUrl）>

	  showImg(url: string): void {
	    this.modalHelper
	      .open(ImgShowComponent, { imgUrl: url }, 'md')
	      .subscribe(() => {});
	  }


测试 正常  

 
### 章节4课时38 Angular主从组件的用法及NgZorro组件Select选择器的使用-1 18:10  

4：46 新建组件book-tag-nzselect   
在cloud-book-list.module.ts中注册BookTagNzselectComponent,  
从[“选择器”](https://ng.ant.design/components/select/zh#components-select-demo-size)中拷贝"随意输入的内容"代码到nz-spin中：   

	<nz-spin [nzTip]="'Loading...'" [nzSpinning]="false">
	  <nz-select nzMode="tags" style="width: 100%;" nzPlaceHolder="请选择或输入图书标签" [(ngModel)]="listOfTagOptions">
	    <nz-option *ngFor="let option of listOfOption" [nzLabel]="option.label" [nzValue]="option.value">
	    </nz-option>
	  </nz-select>
	</nz-spin>

create-or-edit-book.component.html底部添加：    

    <nz-form-item nz-row>
      <nz-form-label nz-col [nzSm]="6" [nzXs]="24" nzFor="BookTag">{{l('BookTag')}}</nz-form-label>
      <nz-form-control nz-col [nzSm]="14" [nzXs]="24">
        <app-book-tag-nzselect></app-book-tag-nzselect>
      </nz-form-control>
    </nz-form-item>

将示例中的数据也拷贝到后台复盖掉ngOnInit(): void {}：   

	  listOfOption = [];
	  listOfTagOptions = [];
	
	  ngOnInit(): void {
	    const children = [];
	    for (let i = 10; i < 36; i++) {
	      children.push({ label: i.toString(36) + i, value: i.toString(36) + i });
	    }
	    this.listOfOption = children;
	  }

添加书籍时底部出现模拟的添加书签项    

08：02使用真实数据   

类BookTagNzselectComponent继承自AppComponentBase，依赖注入constructor(injector: Injector) {super(injector);     

	BookTagNzselectComponent extends AppComponentBase implements OnInit {
	  constructor(injector: Injector) {
	    super(injector);

声明组件，绑到一起   

	@ViewChild('booktag_select') booktag_select: NzSelectComponent;

前台添加(ngModelChange)="modelChange()"方法  修改[nzLabel]="option.lable"为[nzLabel]="option.name"         

	<nz-spin [nzTip]="'Loading...'" [nzSpinning]="false">
	  <nz-select nzMode="tags" style="width: 100%;" nzPlaceHolder="请选择或输入图书标签" [(ngModel)]="listOfTagOptions" (ngModelChange)="modelChange()">
	    <nz-option *ngFor="let option of listOfOption" [nzLabel]="option.name" [nzValue]="option.value">
	    </nz-option>
	  </nz-select>
	</nz-spin>

在资源管理器中执行  nswag>refresh.bat     

create-or-edit-book.component.ts中：  
添加：    

	  tags: any; // 所有书籍的标签
	  selectedTages: any = []; // 已选择的标签集合

init()添加：   

      this.tags = result.bookTags;

submitForm()添加：  

	  input.tagIds = this.selectedTages;

写方法   

	  /**
	   * 获取选择的tag值
	   */
	  tagSelectChange(data: any[]) {
	    this.selectedTages = data;
	  }

15：54

完善(应该更改父组件的流出方法名为(selectedDataChange)与子组件一致，下一讲就不知什么时候修改过来了)        

	<app-book-tag-nzselect name="tag" [tagsSourceData]="tags" (selectTagdataChange)="tagSelectChange($event)"></app-book-tag-nzselect>



 
### 章节4课时39 Angular主从组件的用法及NgZorro组件Select选择器的使用-2 19:11   

视频中说组件名称不能包含两个下划线，所以重新建立一个组件booktag-nzselect，并拷贝代码、删除文件夹，模块中注册BooktagNzselectComponent   

	<app-booktag-nzselect name="tag" [tagsSourceData]="tags" (selectTagdataChange)="tagSelectChange($event)"></app-booktag-nzselect>

提交代码：实现了点击缩略图查看大图，建了select选择器  

选择器代码如下：   可以在没有数据时看到旋转加提示  正在读取数据...    


	<nz-spin [nzTip]="'正在读取数据...'" [nzSpinning]="isLoading">
	  <nz-select #booktagselect nzMode="tags" style="width: 100%;" nzPlaceHolder="请选择或输入图书标签" [(ngModel)]="listOfSelectedValue">
	    <nz-option *ngFor="let option of listOfTagOptions" [nzLabel]="option.tagName" [nzValue]="option.id">
	    </nz-option>
	  </nz-select>
	</nz-spin>


	export class BooktagNzselectComponent extends AppComponentBase
	  implements OnInit {
	  @ViewChild('booktagselect') booktagselect: NzSelectComponent;
	
	  @Output()
	  selectedDataChange = new EventEmitter();
	
	  @Input()
	  set tagsSourceData(value: any) {
	    this.isLoading = true;
	    if (value) {
	      this.listOfTagOptions = value;
	      this.listOfSelectedValue = [];
	      this.listOfTagOptions.forEach(item => {
	        if (item.isSelected) {
	          this.listOfSelectedValue.push(item.id);
	        }
	      });
	    }
	
	    if (this.selectedDataChange) {
	      this.selectedDataChange.emit(this.listOfSelectedValue);
	    }
	
	    this.isLoading = false;
	  }
	  isLoading = true;
	  listOfTagOptions = [];
	  listOfSelectedValue = [];
	
	  constructor(injector: Injector) {
	    super(injector);
	  }
	
	  onSearch() {}
	  modelChange() {}
	  ngOnInit(): void {}
	}

此时，可以在添加、编辑中显示书签列表，但提交修改时显示成功，不能保存到后台数据库


提交代码：完成39课时练习，在添加、编辑中显示书签列表，但提交修改时显示成功，不能保存到后台数据库    


### 章节4课时40 Angular主从组件的用法及NgZorro组件Select选择器的使用-3 38:59   【前端调试】

修改提交：更改了父组件的流出方法名为(selectedDataChange)与子组件一致，完成修改和添加标签的功能。bug：删除完标签不能保存。

解决办法是后端 Update更新方法中去掉  if (tagIds.Count > 0)仅：   

   		await _entityManager.CreateBookAndBookTagRelationship(entity.Id, tagIds);

#### 编辑中自定义标签 

前：  

	<nz-spin [nzTip]="'正在读取数据...'" [nzSpinning]="isLoading">
	  <nz-select #booktagselect nzMode="tags" style="width: 100%;" nzPlaceHolder="请选择或输入图书标签" [(ngModel)]="listOfSelectedValue"
	    (ngModelChange)="modelChange()" (keydown.enter)="handleInputConfirm($event)">
	    <nz-option *ngFor="let option of listOfTagOptions" [nzLabel]="option.tagName" [nzValue]="option.id">
	    </nz-option>
	  </nz-select>
	</nz-spin>

后：   

	
	export class BooktagNzselectComponent extends AppComponentBase
	  implements OnInit {
	  @ViewChild('booktagselect') booktagselect: NzSelectComponent;
	
	  @Output()
	  selectedDataChange = new EventEmitter();
	
	  @Input()
	  set tagsSourceData(value: any) {
	    // 绑定了父组件的属性<app-booktag-nzselect name="tag" [tagsSourceData]="tags"，其实是将父的tags传给了子的value
	    this.isLoading = true;
	    if (value) {
	      this.listOfTagOptions = value;
	      this.listOfSelectedValue = [];
	      this.listOfTagOptions.forEach(item => {
	        if (item.isSelected) {
	          this.listOfSelectedValue.push(item.id);
	        }
	      });
	    }
	
	    if (this.selectedDataChange) {
	      this.selectedDataChange.emit(this.listOfSelectedValue);
	    }
	
	    this.isLoading = false;
	  }
	  isLoading = true;
	  listOfTagOptions = [];
	  listOfSelectedValue = [];
	  searchValue = '';
	
	  constructor(
	    injector: Injector,
	    private _booktagService: BookTagServiceProxy,
	  ) {
	    super(injector);
	  }
	
	  handleInputConfirm(): void {
	    // 过滤掉已存在的值
	    const booktagselectValues = this.booktagselect.listOfSelectedValue;
	    for (let index = 0; index < booktagselectValues.length; index++) {
	      const element = booktagselectValues[index];
	      if (typeof element === 'number') {
	        console.log('已存在于服务器的值');
	      } else {
	        // 检查当前用户是否有权限创建booktag
	        if (this.permission.isGranted('Pages.BookTag.Create')) {
	          this.isLoading = true;
	          const input: CreateOrUpdateBookTagInput = new CreateOrUpdateBookTagInput();
	          const BookTageditDto: BookTagEditDto = new BookTagEditDto();
	          BookTageditDto.tagName = element;
	          input.bookTag = BookTageditDto;
	          this._booktagService
	            .createOrUpdate(input)
	            .pipe(finalize(() => (this.isLoading = false)))
	            .subscribe(res => {
	              const list = this.listOfSelectedValue;
	              for (let d3d = 0; d3d < list.length; d3d++) {
	                const aaa = list[d3d];
	                console.log(aaa);
	              }
	              console.log(res);
	              // todo: 成功的新索引添加到数据库中
	            });
	        }
	      }
	    }
	  }
	
	  modelChange(): void {
	    if (this.selectedDataChange) {
	      this.selectedDataChange.emit(this.listOfSelectedValue);
	    }
	  }
	
	  ngOnInit(): void {}
	}

经调试发现，添加的标签能够以文件名形式存在，已有的以id存在，输入回车的可以保存在标签表中，但重复，不能保存在书中，只要不手动增加新标签是可以的   

### 章节4课时41 通过select选择器和服务器交互以及使用Csharp多返回值Tuple-4 27:05   

后端将新建标签设为public 

	public virtual async Task<BookTagEditDto> Create(BookTagEditDto input)

新建检查标签是否重名的方法 （多返回值）    

        private async Task<(bool result,BookTag entity)> CheckForDuplicateNamesAsync(string tagName)
        {
            var model = await _entityRepository.FirstOrDefaultAsync(a => a.TagName == tagName);

            if (model != null)
            {
                return (result:true,entity:model);
            }

            return (result:false,new BookTag());
        }


Task Update方法添加检测：    

		protected virtual async Task Update(BookTagEditDto input)
		{
			//TODO:更新前的逻辑判断，是否允许更新

			var entity = await _entityRepository.GetAsync(input.Id.Value);
			input.MapTo(entity);

		    var result = await CheckForDuplicateNamesAsync(entity.TagName);  //
		    if (result.result)
		    {
                throw new UserFriendlyException("Tag标签名称重复。");  //
		    }

			// ObjectMapper.Map(input, entity);
		    await _entityRepository.UpdateAsync(entity);
		}

Create新增方法修改为：   

		public virtual async Task<BookTagEditDto> Create(BookTagEditDto input)  //后来
		{
			//TODO:新增前的逻辑判断，是否允许新增
            var entity=input.MapTo<BookTag>();
		    var result = await CheckForDuplicateNamesAsync(entity.TagName);  
		    if (result.result) return result.entity.MapTo<BookTagEditDto>(); 
		    var entityId = await _entityRepository.InsertAndGetIdAsync(entity);
		    entity.Id = entityId;
		    return entity.MapTo<BookTagEditDto>();
		}


同时接口也添加：  

	Task<BookTagEditDto> Create(BookTagEditDto input);

前后端编译 测试，只是id显示太长。但数据库正常       

这个方法弄好就正常了：   
 		
	handleInputConfirm(): void {
	    // 过滤掉已存在的值
	    const booktagselectValues = this.booktagselect.listOfSelectedValue;
	    for (let index = 0; index < booktagselectValues.length; index++) {
	      const element = booktagselectValues[index];
	      if (typeof element === 'number') {
	        console.log('已存在于服务器的值');
	      } else {
	        // 检查当前用户是否有权限创建booktag
	        if (this.permission.isGranted('Pages.BookTag.Create')) {
	          this.isLoading = true;
	          const BookTageditDto: BookTagEditDto = new BookTagEditDto();
	          BookTageditDto.tagName = element;
	
	          this._booktagService
	            .create(BookTageditDto)
	            .pipe(finalize(() => (this.isLoading = false)))
	            .subscribe(res => {
	              // console.log(res);
	              const listOfSelectedValues = this.listOfSelectedValue;
	              const listOfTagOptions = this.listOfTagOptions;
	              for (
	                let selectIndex = 0;
	                selectIndex < listOfSelectedValues.length;
	                selectIndex++
	              ) {
	                if (res.tagName === listOfSelectedValues[selectIndex]) {
	                  listOfTagOptions.push(res);
	                  listOfSelectedValues[selectIndex] = res.id;
	                }
	              }
	            });
	        }
	      }
	    }
	  }

Angular中主从组件的用法  
NgZorro组件Select选择器   
C#7.0多返回值   
配合ng-zorro的选择器做了前端交互的协调    
提升了用户的优化度     


### 章节4课时42 开发完成云书单后端业务逻辑代码 29:58   

core的Relationships/中新建关联表：    

    public class BookListAndBook:CreationAuditedEntity<long>
    {
        public long CloudBookListId { get; set; }
        public CloudBookList CloudBookList { get; set; }  // ？public virtual BookTag BookTag { get; set; }

        public long BookId { get; set; }
        public Book Book { get; set; }  // ？
    }

Book.cs CloudBookList.cs实体表中都添加：

	public virtual ICollection<BookListAndBook> BookListAndBooks { get; set; }  

Ef的BookListDbContext.cs中添加：  

        public DbSet<BookListAndBook> BookListAndBooks { get; set; }  

迁移：  

	PM> add-migration Add_entity_booklistAndBook
	PM> update-database	

代码生成器 CloudBookList.cs   
修改中文名称为：名称、简介，取消最下行BookListAndBook的两个勾选  
按readme操作 （后两个不用操作）    
ctrl+shift+b重新生成   
将生成的前端cloud-books-lists/复制到cloud-book-list/中，删掉原来的book-lists/  
删掉原来注册的组件   
按readme操作  

	npm start

赋给角色权限，搞定   

提交：完成初始化书单   

以下为书单底部增加书籍：    
更改:app/.../dtos/
  
    public class CreateOrUpdateCloudBookListInput
    {
        [Required]
        public CloudBookListEditDto CloudBookList { get; set; }
        public List<long> BookIds { get; set; }  //
    }


CloudBookListApplicationService.cs给，添加Create及编辑Update方法添加参数：   

	,List<long> bookIds

CreateOrUpdate方法返回, input.BookIds：   

		public async Task CreateOrUpdate(CreateOrUpdateCloudBookListInput input)
		{

			if (input.CloudBookList.Id.HasValue)
			{
				await Update(input.CloudBookList,input.BookIds); //
			}
			else
			{
				await Create(input.CloudBookList, input.BookIds); //
			}
		}

Core的BookListManagement/CloudBooksLists/DomainService/ICloudBookListManager.cs接口中添加方法 // 创建book和书单的关系（也可在BookManager）：  

	Task CreateBookListAndBookRelationship(long bookListId, List<long> bookIds);  

实现之：  

	private readonly IRepository<BookListAndBook, long> _bookListAndBookRepository; // 先建仓储并注入

        public async Task CreateBookListAndBookRelationship(long bookListId, List<long> bookIds)
        {
            await _bookListAndBookRepository.DeleteAsync(a => a.CloudBookListId == bookListId);
            await CurrentUnitOfWork.SaveChangesAsync();
            // 创建book和书单的关系
            var insertdBookIds = new List<long>();
            foreach (long bookId in bookIds)
            {
                if (insertdBookIds.Exists(a=>a==bookId))
                {
                    continue;
                }

                await _bookListAndBookRepository.InsertAsync(new BookListAndBook()
                {
                    BookId = bookId,
                    CloudBookListId = bookListId
                });
                insertdBookIds.Add(bookId);
            }
        }

CloudBookListApplicationService.cs中修改方法：  
先引入仓储    

	private readonly IRepository<BookListAndBook, long> _bookListAndBookRepository; //


		protected virtual async Task<CloudBookListEditDto> Create(CloudBookListEditDto input, List<long> bookIds)  //
		{
			//TODO:新增前的逻辑判断，是否允许新增

            // var entity = ObjectMapper.Map <CloudBookList>(input);
            var entity=input.MapTo<CloudBookList>();
		    var entityId = await _entityRepository.InsertAndGetIdAsync(entity);
		    if (bookIds.Count>0)
		    {
		        await _entityManager.CreateBookListAndBookRelationship(entityId, bookIds);
		    }
			return entity.MapTo<CloudBookListEditDto>();
		}

		protected virtual async Task Update(CloudBookListEditDto input,List<long> bookIds)  //
		{
			//TODO:更新前的逻辑判断，是否允许更新

			var entity = await _entityRepository.GetAsync(input.Id.Value);
			input.MapTo(entity);

			// ObjectMapper.Map(input, entity);
		    await _entityRepository.UpdateAsync(entity);
		    if (bookIds.Count > 0)  //
		    {
		        await _entityManager.CreateBookListAndBookRelationship(entity.Id, bookIds);
		    }
        }

删除的因素较多，复制以下代码到接口ICloudBookListManager.cs，并实现：   

        /// 根据书籍Id删除关联
        /// </summary>
        /// <param name="bookId"></param>
        /// <returns></returns>
        Task DeleteByBookId(long? bookId);


        /// <summary>
        /// 根据书籍id集合删除关联
        /// </summary>
        /// <param name="bookIds"></param>
        /// <returns></returns>
        Task DeleteByBookId(List<long> bookIds);


        /// <summary>
        /// 根据书单Id删除关联
        /// </summary>
        /// <param name="bookListId"></param>
        /// <returns></returns>
        Task DeleteByBookListId(long? bookListId);


        /// <summary>
        /// 根据书单id集合删除关联
        /// </summary>
        /// <param name="bookListIds"></param>
        /// <returns></returns>
        Task DeleteByBookListId(List<long> bookListIds);


        public async Task DeleteByBookId(long? bookId)
        {
            await _bookListAndBookRepository.DeleteAsync(a => a.BookId == bookId.Value);
        }

        public async Task DeleteByBookId(List<long> bookIds)
        {
            await _bookListAndBookRepository.DeleteAsync(a => bookIds.Contains(a.BookId));
        }

        public async Task DeleteByBookListId(long? bookListId)
        {
            await _bookListAndBookRepository.DeleteAsync(a => a.BookId == bookListId);
        }

        public async Task DeleteByBookListId(List<long> bookListIds)
        {
            await _bookListAndBookRepository.DeleteAsync(a =>bookListIds.Contains(a.CloudBookListId));
        }

service中调用：  

CloudBookListAppService.cs中：

		/// <summary>
		/// 删除CloudBookList信息的方法
		/// </summary>
		/// <param name="input"></param>
		/// <returns></returns>
		[AbpAuthorize(CloudBookListPermissions.Delete)]
		public async Task Delete(EntityDto<long> input)
		{
		    await _entityManager.DeleteByBookListId(input.Id);   //
			//TODO:删除前的逻辑判断，是否允许删除
			await _entityRepository.DeleteAsync(input.Id);
		}



		/// <summary>
		/// 批量删除CloudBookList的方法
		/// </summary>
		[AbpAuthorize(CloudBookListPermissions.BatchDelete)]
		public async Task BatchDelete(List<long> input)
		{
			// TODO:批量删除前的逻辑判断，是否允许删除
		    await _entityManager.DeleteByBookListId(input); //
			await _entityRepository.DeleteAsync(s => input.Contains(s.Id));
		}

BookApplicationService.cs中：  

先仓储：  

       private readonly ICloudBookListManager _cloudBookListManager;   

        /// <summary>
        /// 删除Book信息的方法
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        [AbpAuthorize(BookPermissions.Delete)]
        public async Task Delete(EntityDto<long> input)
        {
            await _bookAndBookTagRegRepository.DeleteAsync(a => a.BookId == input.Id);  //
            await _entityRepository.DeleteAsync(input.Id);
            await _cloudBookListManager.DeleteByBookId(input.Id); //
        }



        /// <summary>
        /// 批量删除Book的方法
        /// </summary>
        [AbpAuthorize(BookPermissions.BatchDelete)]
        public async Task BatchDelete(List<long> input)
        {
            await _bookAndBookTagRegRepository.DeleteAsync(a => input.Contains(a.BookId)); //
            await _cloudBookListManager.DeleteByBookId(input); //
            await _entityRepository.DeleteAsync(s => input.Contains(s.Id));
            
        }   



### 章节4课时43 使用NgZorro的Select选择器制作bookNzselect 35:22   

前端：  
components中新建组件book-nzselect   
提交：完善后端业务逻辑，以及添加提交书单时的书籍组件book-nzselect  
4：35

	import { NzSelectComponent } from 'ng-zorro-antd';
	import { AppComponentBase } from '@shared/component-base/app-component-base';
	import {
	  Component,
	  OnInit,
	  Inject,
	  Injector,
	  ViewChild,
	  EventEmitter,
	  Output,
	  Input,
	} from '@angular/core';
	import { inject } from '@angular/core/testing';
	
	@Component({
	  selector: 'app-book-nzselect',
	  templateUrl: './book-nzselect.component.html',
	  styles: [],
	})
	export class BookNzselectComponent extends AppComponentBase implements OnInit {
	  constructor(injector: Injector) {
	    super(injector);
	  }
	
	  @ViewChild('select') select: NzSelectComponent;
	  @Output()
	  selectedDataChange = new EventEmitter();
	
	  @Input()
	  bookSourceDataChange = new EventEmitter();
	
	  isLoading = true;
	  listOfTagOptions = [];
	
	  listOfSelectedValue = [];
	
	  @Input()
	  set bookSourceData(value: any) {}
	
	  ngOnInit() {}
	}



	<nz-select style="width: 100%" nzMode="multiple" nzPlaceHolder="Please select" [(ngModel)]="listOfSelectedValue">
	  <nz-option *ngFor="let option of listOfOption" [nzLabel]="option.label" [nzValue]="option.value"></nz-option>
	</nz-select>


注入：   

	BookNzselectComponent,  

父组件create-or-edit-cloud-book-list.component.html中复制并修改添加：   

    <nz-form-item nz-row>
      <nz-form-label [nzSm]="6" [nzXs]="24" nzFor="intro">{{l('Intro')}}</nz-form-label>
      <nz-form-control nz-col [nzSm]="14" [nzXs]="24" nzHasFeedback>
        <app-book-nzselect name='book' [bookSourceData]="books" (selectedDataChange)="bookSelectChange($event)"></app-book-nzselect>
      </nz-form-control>
    </nz-form-item>

13：00    

提交：完成组件内容的第一步。    

后端： Core/../CloudBooksLists/ICloudBookListManager.cs添加接口并实现：    

        /// <summary>
        /// 根据书单Id获取所有关联
        /// </summary>
        /// <param name="bookListId"></param>
        /// <returns></returns>
        Task<List<BookListAndBook>> GetByBookListIdAsync(long? bookListId);


        /// <summary>
        /// 根据书籍Id获取所有关联
        /// </summary>
        /// <param name="bookId"></param>
        /// <returns></returns>
        Task<List<BookListAndBook>> GetByBookIdAsync(long? bookId);


        public async Task<List<BookListAndBook>> GetByBookListIdAsync(long? bookListId)
        {
            return await _bookListAndBookRepository.GetAll()
                .AsNoTracking()
                .Where(o => o.CloudBookListId == bookListId.Value)
                .ToListAsync();
        }

        public async Task<List<BookListAndBook>> GetByBookIdAsync(long? bookId)
        {
            return await _bookListAndBookRepository.GetAll()
                .AsNoTracking()
                .Where(o => o.BookId == bookId.Value)
                .ToListAsync();
        }


App新建DTO： BookSelectListDto : BookListDto：   

    public class BookSelectListDto : BookListDto
    {
        /// <summary>
        /// 是否选中
        /// </summary>
        public bool IsSelected { get; set; }
    }

BookMapper.cs中添加：     

            configuration.CreateMap<Book, BookSelectListDto>()
                .ForMember(a => a.IsSelected, options => options.Ignore()); 

强化App/../CloudBooksLists/Dtos/GetCloudBookListForEditOutput.cs:      

    public class GetCloudBookListForEditOutput
    {

        public CloudBookListEditDto CloudBookList { get; set; }
        public List<BookSelectListDto> Books { get; set; } //
    }

修改业务逻辑CloudBookListApplicationService.cs：     

	   private readonly IRepository<Book, long> _bookRepository; // 要注入

		public async Task<GetCloudBookListForEditOutput> GetForEdit(NullableIdDto<long> input)
		{
			var output = new GetCloudBookListForEditOutput();
			CloudBookListEditDto editDto;
		    var allBooklistDtos = (await _bookRepository.GetAllListAsync()).MapTo<List<BookSelectListDto>>();

            if (input.Id.HasValue)
			{
				var entity = await _entityRepository.GetAsync(input.Id.Value);

				editDto = entity.MapTo<CloudBookListEditDto>();

				//cloudBookListEditDto = ObjectMapper.Map<List<cloudBookListEditDto>>(entity);

			    var bookids= (await _entityManager.GetByBookListIdAsync(entity.Id)).Select(a=>a.BookId).ToList();
			    
			    foreach (var book in allBooklistDtos)
			    {
			        if (bookids.Exists(a => a == book.Id))
			        {
			            book.IsSelected = true;
			        }
			    }

			}
			else
			{
				editDto = new CloudBookListEditDto();
			}

			output.CloudBookList = editDto;
		    output.Books = allBooklistDtos;
			return output;
		}

22：40  重新生成并前端refrsh.bat   

create-or-edit-cloud-book-list.component.ts:    

	books: any = []; //  
	selectBooks: any = []; //

	  init(): void {
	    this._cloudBookListService.getForEdit(this.id).subscribe(result => {
	      this.entity = result.cloudBookList;
	      this.books = result.books;  //   
	    });
	  }

	  bookSelectChange(data: any) {       ////
	    this.selectBooks = data;
	  }

25:31 测试   

book-nzselect.component.ts：     

	  @Input()
	  set bookSourceData(values: any) {
	    this.isLoading = true;
	    if (values) {
	      this.listOfOption = values;
	      this.listOfSelectedValue = [];
	      this.listOfOption.forEach(item => {
	        if (item.isSelected) {
	          this.listOfSelectedValue.push(item.id);
	        }
	      });
	    }
	    if (this.selectedDataChange) {
	      this.selectedDataChange.emit(this.listOfSelectedValue);
	    }
	    this.isLoading = false;
	  }
	


页面添加：   

	(ngModelChange)="modelChange()"

添加方法：  

	  modelChange(): void {
	    if (this.selectedDataChange) {
	      this.selectedDataChange.emit(this.listOfSelectedValue);
	    }
	  }

同时@Input（） 最后this.isLoading = false;前添加：  

    if (this.selectedDataChange) {
      this.selectedDataChange.emit(this.listOfSelectedValue);
    }


### 章节4课时44 完成云书单项目的功能 10:02  

create-or-edit-cloud-book-list.component.ts   submitForm()方法添加：    

	input.bookIds = this.selectBooks; //
	
	
	submitForm(): void {
	    const input = new CreateOrUpdateCloudBookListInput();
	    input.cloudBookList = this.entity;
	
	    input.bookIds = this.selectBooks; //
	
	    this.saving = true;
	
	    this._cloudBookListService
	      .createOrUpdate(input)
	      .finally(() => (this.saving = false))
	      .subscribe(() => {
	        this.notify.success(this.l('SavedSuccessfully'));
	        this.success(true);
	      });
	  }
	
	  bookSelectChange(data: any) {
	    this.selectBooks = data;
	  }

book-nzselect.component.html  将(ngModelChange)="modelChange()"放到外边：   


	<nz-spin [nzTip]="'Loading...'" [nzSpinning]="false">
	  <nz-select style="width: 100%" nzMode="multiple" nzPlaceHolder="Please select" [(ngModel)]="listOfSelectedValue"
	    (ngModelChange)="modelChange()">
	    <nz-option *ngFor="let option of listOfOption" [nzLabel]="option.name" [nzValue]="option.id"></nz-option>
	  </nz-select>
	</nz-spin>


 前台可添加 {{selectBooks|json}} 以显示选定的值，开发时有用：   

    <nz-form-item nz-row>
      <nz-form-label [nzSm]="6" [nzXs]="24" nzFor="intro">{{l('Books')}}</nz-form-label>
      <nz-form-control nz-col [nzSm]="14" [nzXs]="24" nzHasFeedback>
        <app-book-nzselect name='book' [bookSourceData]="books" (selectedDataChange)="bookSelectChange($event)"></app-book-nzselect>
      </nz-form-control>
      <!-- {{selectBooks|json}} -->
    </nz-form-item>



修改为卡片式  cloud-book-list.component.html最后删除，再添加：    


	<!-- 以下为卡片式代码从仓库中复制过来 -->
	
	  <nz-list [nzLoading]="isTableLoading" [nzDataSource]="dataList" [nzRenderItem]="itemTemplate" [nzGrid]="{ gutter: 24, xxl: 8, xl: 12, lg: 12, md: 12, sm: 12, xs: 24 }">
	    <ng-template #itemTemplate let-item>
	      <nz-list-item>
	        <nz-card nzHoverable [nzActions]="[op1,op2,op3]">
	          <ng-template #op1>
	            <a (click)="createOrEdit(item.id)">
	              <i nz-tooltip class="anticon anticon-edit" *ngIf="appSession.tenantId"></i>
	              <i nz-tooltip class="anticon anticon-search" *ngIf="!appSession.tenantId"></i>
	            </a>
	          </ng-template>
	          <ng-template #op2>
	            <nz-popconfirm [nzTitle]="l('ConfirmDeleteWarningMessage')" (nzOnConfirm)="delete(item)" [nzOkText]="l('Ok')"
	              [nzCancelText]="l('Cancel')">
	              <a nz-popconfirm>
	                <i class="anticon anticon-delete mr-sm"></i>
	              </a>
	            </nz-popconfirm>
	          </ng-template>
	          <ng-template #op3>
	            <a (click)="shareQrCode(item.id)">
	              <i nz-tooltip class="anticon anticon-share-alt"></i>
	            </a>
	          </ng-template>
	          <nz-card-meta [nzTitle]="nzTitle" [nzAvatar]="nzAvatar">
	            <ng-template #nzTitle>
	              <h2> {{item.name}} </h2>
	            </ng-template>
	            <ng-template #nzAvatar>
	              <label nz-checkbox [(ngModel)]="item.checked" (nzCheckedChange)="refreshCheckStatus(dataList)"></label>
	            </ng-template>
	          </nz-card-meta>
	          <div class="card-info d-flex">
	            <div>
	              <p>{{item.creationTime |_date}}</p>
	              <p>{{item.intro}}</p>
	
	            </div>
	          </div>
	        </nz-card>
	      </nz-list-item>
	    </ng-template>
	  </nz-list>

之上添加全选框（通用） ：  

	<label nz-checkbox [(ngModel)]="allChecked" (nzCheckedChange)="checkAll($event)" [nzDisabled]="allCheckboxDisabled">{{l("SelectAll")}}</label>

补充：  

	  // 分享二维码功能
	  shareQrCode(id: string) {
	    const url = AppConsts.appBaseUrl + '/public/book-list-share;id=' + id;
	    // this.modalHelper.open();
	  }
	
	  // todo://多租户功能//二维码分享//增强性的功能
 
### 章节4课时45 多租户介绍及ABP中如何将项目修改Saas化的多租户项目 20:32 

五个实体添加继承并实现之，每个多了public int TenantId { get; set; }：   

	, IMustHaveTenant

迁移：    

	PM> add-migration Add_tenant_for_someEntities
	PM> update-database

数据库执行：  

	update [dbo].[BookAndBookTags] set TenantId=1
	update [dbo].[BookListAndBooks] set TenantId=1
	update [dbo].[Books] set TenantId=1
	update [dbo].[BookTags] set TenantId=1
	update [dbo].[CloudBookLists] set TenantId=1  

打开多租户：  

	public const bool MultiTenancyEnabled = true;

重新编译运行  登录切换租户为Default  正常       
提交：修改云书单项目为多租户项目     
  
### 章节4课时46 多租户授权模式和租户管理员创建流程 35:43   

前端account中新建组件tenant-register,其中再新建tenant-register-component.less文件，将yoyo中的代码拷进来。   
html代码从文档中拷入表单的注册代码到以下中：  

	<nz-spin [nzTip]="'注册租户功能...'" [nzSpinning]="saving">
	
	</nz-spin>

account.module.ts的declarations添加模块：  

	TenantRegisterComponent，
   

修改tenant-register-component.ts:     
	
	@Component({
	  selector: 'app-tenant-register',
	  templateUrl: './tenant-register.component.html',
	  styles: ['./tenant-register.component.less']
	})
	export class TenantRegisterComponent extends AppComponentBase implements OnInit {
	
	  constructor(injector: Injector) {
	    super(injector);
	   }
	
	  ngOnInit() {
	  }
	
	}


login.componet.html中添加入口:  

          <span>
            <a routerLink="/account/tenant-register">创建租户信息</a>
            <nz-divider nzType="vertical"></nz-divider>
          </span>

account-routing.module.ts注册路由：     

	{ path: 'tenant-register', component: TenantRegisterComponent },

可以导航到http://localhost:8080/account/tenant-register，但乱码多    



数据绑定页：    



先写后端  app/MultiTenancy/中新增接口ITenantRegistrationAppService.cs因为原来的TenanAppService.cs： 
中的方法要首先通过验证，所以重写 14：04               

    public interface ITenantRegistrationAppService:IApplicationService
    {
        /// <summary>
        /// 公开注册租户功能
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        Task<TenantDto> RegisterTenantAsync(CreateTenantDto input);
    }


app/MultiTenancy/TenanAppService.cs： 

    public class TenantRegistrationAppService:BookListAppServiceBase, ITenantRegistrationAppService
    {
        private readonly EditionManager _editionManager;
        private readonly RoleManager _roleManager;
        private readonly IAbpZeroDbMigrator _abpZeroDbMigrator;
        private readonly IPasswordHasher<User> _passwordHasher;

        public TenantRegistrationAppService( EditionManager editionManager, RoleManager roleManager, IAbpZeroDbMigrator abpZeroDbMigrator, IPasswordHasher<User> passwordHasher)
        {
            _editionManager = editionManager;
            _roleManager = roleManager;
            _abpZeroDbMigrator = abpZeroDbMigrator;
            _passwordHasher = passwordHasher;
        }

        public async Task<TenantDto> RegisterTenantAsync(CreateTenantDto input)
        {
            var tenant = new Tenant(input.TenancyName,input.Name)
            {
                IsActive = true
            };
            // 连接字串要加密
            tenant.ConnectionString = input.ConnectionString.IsNullOrEmpty()
                ? null
                : SimpleStringCipher.Instance.Encrypt(input.ConnectionString);
            // 获得默认的版本信息 DefaultEditionName = "Standard"
            var defaultEdition = await _editionManager.FindByNameAsync(EditionManager.DefaultEditionName);
            if (defaultEdition != null)
            {
                tenant.EditionId = defaultEdition.Id;
            }
            // 创建租户信息
            await TenantManager.CreateAsync(tenant);
            await CurrentUnitOfWork.SaveChangesAsync();
            // 初始化数据信息迁移，针对租户级
            _abpZeroDbMigrator.CreateOrMigrateForTenant(tenant);
            // 所以设置当前的工作单元为新注册登录的租户信息
            using (CurrentUnitOfWork.SetTenantId(tenant.Id))
            {
                // 创建租户
                CheckErrors(await _roleManager.CreateStaticRoles(tenant.Id));
                // role =admin permission user
                await CurrentUnitOfWork.SaveChangesAsync();
                // 创建角色
                var adminRole = _roleManager.Roles.Single(a => a.Name == StaticRoleNames.Tenants.Admin);
                // 授权当前角色所有权限
                await _roleManager.GrantAllPermissionsAsync(adminRole);
                // 创建admin用户信息
                var adminUser = User.CreateTenantAdminUser(tenant.Id, input.AdminEmailAddress);
                // 密码为空时提供默认密码
                adminUser.Password = _passwordHasher.HashPassword(adminUser,StringExtensions.IsNullOrWhiteSpace(input.PassWord)?User.DefaultPassword:input.PassWord);
                CheckErrors(await UserManager.CreateAsync(adminUser));
                await CurrentUnitOfWork.SaveChangesAsync();
                // 角色授权给用户
                CheckErrors(await UserManager.AddToRoleAsync(adminUser,adminRole.Name));
                await CurrentUnitOfWork.SaveChangesAsync();
            }

            return tenant.MapTo<TenantDto>();
        }
    }


CreateTenantDto.cs添加属性：   

	public string PassWord { get; set; }




运行 并TenantRegistration执行以下成功：

	{
	  "tenancyName": "ltm2",
	  "name": "ltm2",
	  "adminEmailAddress": "ltm2.qq.com",
	  "isActive": true,
	  "passWord": "123qwe"
	}

前端切换租户ltm2用admin 123qwe可以登录，仅少数据  

提交：完成 课时46 多租户授权模式和租户管理员创建流程

### 章节4课时47 使用Angular前端组件qrcode生成二维码功能 26:52   

前端执行refresh.bat 修改 tenant-register.component.ts：     

	export class TenantRegisterComponent extends AppComponentBase implements OnInit {
	  model: CreateTenantDto = new CreateTenantDto();
	
	  // tslint:disable-next-line:max-line-length
	  constructor(injector: Injector, private _tenantService: TenantRegistrationServiceProxy, private _loginService: LoginService, private _router: Router) {
	    super(injector);
	   }
	
	  ngOnInit() {
	  }
	
	  back(): void {
	    this._router.navigate(['/account/login']);
	   }
	
	  save(): void {
	    this.saving = false;
	    this._tenantService.registerTenantAsync(this.model).pipe(
	      finalize(() => {
	        this.saving = false;
	      }),
	    )
	      .subscribe(result => {
	        this.notify.success(this.l('SavedSuccessfully'));
	        this.saving = true;
	        abp.multiTenancy.setTenantIdCookie(result.id);
	
	        this._loginService.authenticateModel.userNameOrEmailAddress = this.model.adminEmailAddress;
	        this._loginService.authenticateModel.password = this.model.passWord;
	        this._loginService.authenticate(() => {
	          this.saving = false;
	        });
	    });
	  }
	
	}

将html less文件从gitee的项目中拷贝过来  

增加动画效果：   

		,
	  animations: [appModuleAnimation()],


shared/service-proxies/service-proxy.module.ts添加注入：   

	ApiServiceProxies.TenantRegistrationServiceProxy,

能注册租户成功，但提示少密码字段  注册界面也有问题-全屏了    

提交：完成前后端多租户功能的开发（能注册租户成功，但提示少密码字段  注册界面也有问题-全屏了）         


18：18 二维码     

ctrl+c  

	booklist-angular>yarn add angular2-qrcode

新建模块/shared/components/share-qrcode   

	export class ShareQrcodeComponent extends ModalComponentBase {
	  qrcodeUrl: string;
	  constructor(injector: Injector) {
	    super(injector);
	   }
	} 
	
	<qr-code [value]="qrcodeUrl" [size]="256" *ngIf="qrcodeUrl" style="width:256px;;display: block;margin:0 auto;"></qr-code>
	<span>{{qrcodeUrl}}</span>


custom-components.module.ts注入依赖： 

	const ThirdDirectives = [
	  AutoFocusDirective,
	  EqualValidator,
	  MinValueValidator,
	  PasswordComplexityValidator,
	  ShareQrcodeComponent, //
	];  

	@NgModule({
	  imports: [CommonModule, QRCodeModule], //
	  declarations: [...COMPONENTS, ...ThirdDirectives],
	  entryComponents: [ShareQrcodeComponent], //
	  exports: [...COMPONENTS],
	})


cloud-book-list.component.html：     
（原来的代码，拷过来供参考）     
	
	 <ng-template #op3>
	            <a (click)="shareQrCode(item.id)">
	              <i nz-tooltip class="anticon anticon-share-alt"></i>
	            </a>
	          </ng-template>

cloud-book-list.component.ts：    

	  // 分享二维码功能
	  shareQrCode(id: string, tid: string) {
	    const url = AppConsts.appBaseUrl + '/public/book-list-share;tid=' + tid +
	     ';id=' + id;
	    this.modalHelper
	      .open(ShareQrcodeComponent, { qrcodeUrl: url }, 'sm')
	      .subscribe(() => {});
	  }
	
	  // todo://多租户功能  //二维码分享//增强型的功能

分享书单时能生成二维码，并且显示链接为http://localhost:8080/public/book-list-share;tid=undefined;id=16，租户id没显示出来  

提交:完成 课时47 使用Angular前端组件qrcode生成二维码功能（租户id没显示出来tid=undefined）
仓库提示依赖项存在安全漏洞:We found potential security vulnerabilities in your dependencies.

### 章节4课时48 完善二维码访问创建云书单公共分享页面 46:02   

cloud-book-list.component.ts：    

注入：    

	private _abpsession: AbpSessionService,

分享二维码功能修改为：   

	  shareQrCode(userid: string) {
	    const tid = this._abpsession.tenantId;
	    const url =
	      AppConsts.appBaseUrl +
	      '/public/book-list-share;tid=' +
	      tid +
	      ';id=' +
	      userid;
	    this.modalHelper
	      .open(ShareQrcodeComponent, { qrcodeUrl: url }, 'sm')
	      .subscribe(() => {});
	  }

这次可以得到地址好了为：

	http://localhost:8080/public/book-list-share;tid=5;id=16

创建云书单公共分享页面：     

src中创建公共模块public，其中新建组件book-list-share（与以上地址对应）    
    
将PublicModule注册到最外层路由root-routing.module.ts中：   
	
		,
	  {
	    path: 'public',
	    loadChildren: 'public/public.module#PublicModule',
	    data: {},
	  },

改造public.module.ts：     

	@NgModule({
	  imports: [
	    CommonModule,
	    FormsModule,
	    HttpModule,
	    JsonpModule,
	    NgZorroAntdModule,
	    AbpModule,
	    SharedModule,
	    ServiceProxyModule,
	    PublicRoutingModule,
	  ],
	  declarations: [BookListShareComponent, PublicComponent],
	  entryComponents: [],
	})

内部路由public/public-routing.module.ts:   

	const routes: Routes = [
	  {
	    path: '',
	    component: PublicComponent,
	    children: [
	      {
	        path: 'book-list-share',
	        component: BookListShareComponent,
	      },
	    ],
	  },
	];

public.component.html引入book-list-share组件：   

	<p>
	  public works!
	</p>
	<app-book-list-share></app-book-list-share>

重启可以访问共享地址了     

提交： 补充public公共模块和公共组件，增加书单分享组件内容。   

从gitee拷贝代码至public.component.html public.component.less  book-list-share.component.html        
public.component.ts引入样式：  

	styleUrls: ['./public.component.less'],  //

book-list-share.component.ts代码：   

	export class BookListShareComponent extends AppComponentBase implements OnInit {
	  id: number;
	  tid: number;
	  loading = false;
	  entity: BookListDto;
	  constructor(injector: Injector) {
	    super(injector);
	  }
	
	  ngOnInit() {}
	}

此时，重开浏览器，可以绕过权限访问页面，但无内容        

#### 后端

App../CloudBookLists/Dtos/中新建 CloudBookListShareDto.cs   

    public class CloudBookListShareDto
    {
        public string Name { get; set; }
        public string Intro { get; set; }
        public DateTime CreationTime { get; set; }
        public List<BookIncludeTagDto> Books { get; set; }
        public string UserName { get; set; }
    }

App../Books/Dtos/中新建 BookIncludeTagDto.cs 内部所有属性从BookListDto.cs中拷过来，最后添加一个List<string> BookTags ，不知为什么不继承   

        /// <summary>
    /// 书籍包含标签
    /// </summary>
    public class BookIncludeTagDto
    {
        /// <summary>
        /// 书名
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// 作者
        /// </summary>
        public string Author { get; set; }

        /// <summary>
        /// 简介
        /// </summary>
        public string Intro { get; set; }
        
        /// <summary>
        /// 购买链接
        /// </summary>
        public string PriceUrl { get; set; }

        /// <summary>
        /// 图片链接
        /// </summary>
        public string ImgStrUrl { get; set; }

        public List<string> BookTags { get; set; }
    }


BookMapper.cs配置MAp：     
   
	configuration.CreateMap<Book, BookIncludeTagDto>().ForMember(a=>a.BookTags,memberOptions:opt=>opt.Ignore());  // 将Book映射到BookSelectListDto 忽略掉BookTags

CloudBookListMapper.cs配置MAp：   

	configuration.CreateMap<CloudBookList, CloudBookListShareDto>().ForMember(o=>o.UserName,opt=>opt.Ignore())
                .ForMember(o=>o.Books,opt=>opt.Ignore());


BookApplicationService.cs取消服务的整个授权         

	//    [AbpAuthorize]

IBookApplicationService.cs添加方法：

        /// <summary>
        /// 获取分享书单信息的接口
        /// </summary>
        /// <param name="cloudbookListId">云书单ID内容</param>
        /// <param name="tenantId"></param>
        /// <returns></returns>
        Task<CloudBookListShareDto> GetBookListShareAsync(long cloudbookListId,int tenantId);

前端修改一下参数名称userId为cloudbookListId:   

	  // 分享二维码功能
	  shareQrCode(cloudbookListId: string) {
	    const tid = this._abpsession.tenantId;
	    const url =
	      AppConsts.appBaseUrl +
	      '/public/book-list-share;tid=' +
	      tid +
	      ';id=' +
	      cloudbookListId;
	    this.modalHelper
	      .open(ShareQrcodeComponent, { qrcodeUrl: url }, 'sm')
	      .subscribe(() => {});
	  }

实现上面的接口：  

添加依赖注入：  

	private readonly IRepository<CloudBookList, long> _cloudBookListRepository;


        public async Task<CloudBookListShareDto> GetBookListShareAsync(long cloudbookListId, int tenantId)
        {
            if (cloudbookListId <= 0||tenantId<=0)
            {
                throw new UserFriendlyException(message:"租户或书单ID不能为空");
            }

            var tenant = await TenantManager.GetByIdAsync(tenantId);
            if (tenant==null)
            {
                throw new UserFriendlyException(message: "该租户下没有书单");
            }
            // 设置当前工作单元的租户ID
            using (CurrentUnitOfWork.SetTenantId(tenantId))
            {
                // 获取云书单内容信息
                var cloudBookList = await _cloudBookListRepository.GetAll().IgnoreQueryFilters()
                    .Where(b => b.Id == cloudbookListId).FirstOrDefaultAsync();
                var dto= cloudBookList.MapTo<CloudBookListShareDto>();
                if (cloudBookList.CreatorUserId.HasValue)
                {
                    var user = UserManager.Users.IgnoreQueryFilters()
                        .FirstOrDefaultAsync(d => d.Id == cloudBookList.CreatorUserId);
                    dto.UserName = user.Result.UserName;  // 视频中是user.UserName
                }
                // 当前书单下是否有书籍内容
                if (cloudBookList.BookListAndBooks==null)
                {
                    return dto;
                }
                dto.Books=new List<BookIncludeTagDto>();
                foreach (var bookListAndBook in cloudBookList.BookListAndBooks)
                {
                    // 获取书籍dto
                    var bookdto = bookListAndBook.Book.MapTo<BookIncludeTagDto>();
                    dto.Books.Add(bookdto);
                    if (bookListAndBook.Book.BookAndBookTags==null)
                    {
                        continue;
                    }
                    // 书籍标签的处理
                    bookdto.BookTags=new List<string>();
                    foreach (var bookAndbookTag in bookListAndBook.Book.BookAndBookTags)
                    {
                        bookdto.BookTags.Add(bookAndbookTag.BookTag.TagName);
                    }
                }

                return dto;
            }


        }

测试，有返回数据，但没有拿到书签内容      


### 章节4课时49 懒加载使用完成云书单项目以及下一阶段事宜说明 35:32   

修改此句为贪婪加载后，可以拿到书签内容了：

                // 获取云书单内容信息
                var cloudBookList = await _cloudBookListRepository.GetAll()
                    .Include(a=>a.BookListAndBooks)
                    .ThenInclude(a=>a.Book)
                    .ThenInclude(a=>a.BookAndBookTags)
                    .ThenInclude(a=>a.BookTag)
                    .IgnoreQueryFilters()
                    .Where(b => b.Id == cloudbookListId).FirstOrDefaultAsync();    

提交：完成多租户下的书单共享接口。

4：00-21：25 更改加载方式为懒加载，但未成功,可能是版本未统一。基本操作是：    
删除掉上面贪婪加载的代码  
EF安装Microsoft.EntityFrameworkCore.Proxies   
实体对象的外链要标识virtual   
    
21:25 前端：   
刷新接口   
book-list-share.component.ts：       

	export class BookListShareComponent extends AppComponentBase implements OnInit {
	  id: number;
	  tid: number;
	  loading = false;
	  entity: CloudBookListShareDto;
	  constructor(
	    injector: Injector,
	    private _activatedRoute: ActivatedRoute,
	    private _bookService: BookServiceProxy,
	  ) {
	    super(injector);
	  }
	
	  ngOnInit() {
	    this.id = this._activatedRoute.snapshot.params['id'];
	    this.tid = this._activatedRoute.snapshot.params['tid'];
	    // 查询数据
	    if (this.tid && this.id) {
	      this._bookService
	        .getBookListShareAsync(this.id, this.tid)
	        .pipe(
	          finalize(() => {
	            this.loading = false;
	          }),
	        )
	        .subscribe(result => {
	          this.entity = result;
	        });
	    }
	  }
	
	  // 分享二维码功能  从前面复制修改
	  shareQrCode() {
	    const tid = this.tid;
	    const cloudbookListId = this.id;
	    const url =
	      AppConsts.appBaseUrl +
	      '/public/book-list-share;tid=' +
	      tid +
	      ';id=' +
	      cloudbookListId;
	    this.modalHelper
	      .open(ShareQrcodeComponent, { qrcodeUrl: url }, 'sm')
	      .subscribe(() => {});
	  }
	}
	   
提交：完成云书单项目功能。         


说明：

此版不再更新   [yoyosoft.BookList](https://gitee.com/aiabpedu/yoyosoft.BookList)      
更新的版本是	[Cloud.BookList](https://gitee.com/aiabpedu/Cloud.BookList)  

最新演示版是  [admin.yoyocms.com](https://pro.52abp.com/account/login)  
演示版源码是  [LTMCompanyName.YoyoCmsTemplate](https://gitee.com/aiabpedu/LTMCompanyName.YoyoCmsTemplate)      
	
	


## 章节5  52ABP快速开发-中高级篇   
### 章节5课时50 模块化设计及ABP启动加载说明 32:23   

"Default": "Data Source=.; Database=YoyoCmsTemplate_db; User ID=52abp; Password=52abp;"





















### 章节5课时51 依赖注入的好处和场景说明及abp中如何使用控制反转 27:42     
### 章节5课时52SwaggerUI的增强添加注释换肤多版本控制等 34:24    
### 章节5课时5352ABP框架中的Excel导出功能的设计说明和实现1 14:04     
### 章节5课时54Excel功能使用Epplus的基类以及缓存文件的领域服务的实现2 21：43     
### 章节5课时55Excel导出功能实现User表功能的导出 14:20    
### 章节5课时56利用缓存领域服务来下载Excel文件完成导出功能 12:39    
### 章节5课时57迁移Sqlserver数据库到Postgresql数据库的案例讲解 16:13     
### 章节5课时58迁移Sqlserver数据库到Mysqll数据库的案例 10:40    
### 章节5课时59如何在52abp框架中对Abpsession的扩展-1 12:57     
### 章节5课时60如何在52abp框架中对Abpsession的扩展-2 14:39    











